**Document number:** D0800R0

**Date:** 2017-08-28

**Audience:** Evolution Working Group

**Reply-to:** Christopher Di Bella <christopher@codeplay.com>

# The Concepts TS improves upon C++

## Abstract

There is concern that the Concepts TS does not improve C++, and that it might not be necessary.
This paper addresses some concerns, and considers why having and using (but not necessarily writing)
concepts is beneficial to the average C++ programmer.

## Contents

1. [Introduction](#introduction)
2. [Definitions](#definitions)
3. [Error messages with Concepts and Ranges](#error-messages-with-concepts-and-ranges)
4. [Generic programming with Concepts](#generic-programming-with-concepts)
5. [Generic programming in C++17](#generic-programming-in-c17)
6. [Conclusion](#conclusion)
7. [Acknowledgements](#acknowledgements)
8. [References](#references)
9. [Appendix A](#appendix-a)

## Introduction

This paper addresses some of the concerns that some programmers have about whether the Concepts TS
contributes to the C++ programming language.

### Definitions

* **Modern C++** refers to any C++ Standard published since 2011.
* **Concepts TS** is shorthand for _ISO/IEC TS 19217:2015, Programming Languages
  -- C++ Extensions for Concepts_.
* **Concepts** is shorthand for the Concepts TS
* **concept** refers to an individual `concept` written in code
* **Ranges TS** is shorthand for _N4685, Working Draft, C++ Extensions for Ranges_.
* **Ranges** is shorthand for the Ranges TS.
* **Novice C++ programmer** (or some variant) refers to a C++ programmer with less than three years
  experience with modern C++.
* **Average C++ programmer** (or some variant) refers to a C++ programmer with three or more years
  experience with modern C++.
* **Expert C++ programmer** (or some variant) refers to a C++ programmer that satisfies at least one
  of the following criteria:
  1. attends WG21-related meetings (e.g. this meeting)
  2. attends WG21-related calls (e.g. SG14 telecons)
  3. contributes to Standard proposal papers
  4. contributes to a modern C++ compiler (e.g. GCC)
  5. contributes to a modern C++ Standard Library (e.g. libc++)
  6. contributes to a modern C++ library similar to the Standard Library (e.g. Boost, range-v3, etc.)
  7. contributes to a reference implementation for a Standard proposal or Technical Specification
     (e.g. cmcstl2)
  8. has ten or more years experience with C++, particularly with templates, including template
     metaprogramming (includes using Boost.MPL)
* **Clang** or **LLVM** refer to the C++ implementation of LLVM 5.
  * **libc++** refers to the LLVM implementation of the C++ Standard Library,
    provided by the flag `-stdlib=libc++` to Clang.
* **GCC** refers to the C++ implementation of GCC 7.
  * **libstdc++** refers to the GCC implementation of the C++ Standard Library.
* **MSVC** refers to the C++ implementation of Microsoft Visual C++ 2017.

All compiler diagnostics are provided through Matt Godbolt's _Compiler Explorer_, and are also
present in Appendix A for offline viewing. Following the links to Compiler Explorer is advised.

## Error messages with Concepts and Ranges

One particular concern is that Concepts do not improve compiler diagnostics. To illustrate, we'll
consider the following two programs:

* Listing 1. [Without concepts](https://godbolt.org/g/S2v4Bh)

```cpp
#include <algorithm>
#include <iterator>
#include <list>

int main()
{
  auto l = std::list{1, 2, 3, 4, 5};
  std::sort(std::begin(l), std::end(l));
}
```

* Listing 2. [With concepts](https://godbolt.org/g/wqgvdH)

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <list>

namespace ranges = std::experimental::ranges;

int main()
{
  auto l = std::list{1, 2, 3, 4, 5};
  ranges::sort(ranges::begin(l), ranges::end(l));
}
```

Both diagnostics -- on their own and at a first glance -- appear to be expert-friendly. Both are
incredibly verbose, which can be indimidating, and the `ranges::sort` is sufficiently more verbose.
This does not mean that it is sufficiently more expert-friendly than `std::sort`: instead, it opens
opportunities for tools to provide more _informative_ diagnostics. At present, this might be using a
third-party tool that only reveals certain text from the diagnostic (e.g. showing only the parts
that match the regular expression "concept bool\W+\w+\W*="); in future, it might be possible for a
compiler to implement a feature that cleans up the diagnostics further.

It's not possible to do this solely with template diagnostics because the template does not contain
the necessary information. The information that is spewed from `std::sort` rambles on about an
`operator-` that the user has not implemented. The only piece of information that is actually
informative is `_RandomAccessIterator`, but this isn't easily findable when using libc++, and there
is no mention of the word 'random' in the diagnostic from MSVC 2017 at all. Since all three major
compilers discuss `operator-`, and only two of them mention 'random' (almost in passing), the
following information can be inferred from the diagnostic:

1. It has something to do with `std::sort` (given that libstdc++ talks about `std::__sort`, libc++
   talks about `std::__1::__insertion_sort`, and MSVC talks about both `std::sort` and
   `std::_Sort_unchecked`).
2. It has something to do with `operator-`

In contrast, `ranges::sort` spews diagnostics regarding the interface for `sort`. There is rambling,
but it explicitly mentions a few key words:

1. `std::experimental::ranges::v1::sort`
2. `concept bool RandomAccessIterator`
3. `concept bool DerivedFrom`
4. `concept bool SizedSentinel`
5. `concept bool StrictTotallyOrdered`
6. `concept bool __totally_ordered`
7. `concept bool RandomAccessIncrementable`
8. `concept bool RandomAccessIterator`
9. `RandomAccessRange and Sortable`

Even most of this is noise, but we get a lot more information. Firstly, there's no mention of
`operator-`, which is an _implementation detail_ of the sort algorithm. This means that we are left
to consider how we interact with our algorithm. The diagnostic provided by the concept also mentions
the term `RandomAccess` four times: this means that we're likely violating some contract that asks
for a random access data structure: this is a topic that is covered in the first year of computer
science at university, or when `std::list` is introduced in a well-written resource (there's no need
to discuss random access and linear access until a non-`vector` container appears).

As previously stated, the diagnostics can be improved upon here: what we currently have is a
prototype.

The quality of diagnostics is a strong motivator for using concepts, but it's not the only reason to
use them. There's more on that below. If the use of concepts served solely as a vehicle to improve
diagnostics, the compiler might not be the tool to grok the diagnostics: we use other tools, such as
IDEs, lint tools, and static analysers. Perhaps one of these can pick up when a compiler struggles
to provide ample documentation. Recall that the Standard does not specify _how_ diagnostics are to
be output -- only that they are -- and users who prefer not to use tools can request better
diagnostics from their compiler vendor.

----------------------------------------------------------------------------------------------------

Let's now consider sorting on a type that can't be compared.

* Listing 3. [Without concepts](https://godbolt.org/g/5h3NqK)

```cpp
#include <algorithm>
#include <iterator>
#include <vector>

class Foo {};

int main()
{
  auto l = std::vector<Foo>{};
  std::sort(std::begin(l), std::end(l));
}
```

* Listing 4. [With concepts](https://godbolt.org/g/BQruYa)

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <vector>

namespace ranges = std::experimental::ranges;

class Non_sortable {};

int main()
{
  auto l = std::vector<Non_sortable>{};
  ranges::sort(ranges::begin(l), ranges::end(l));
}
```

Toward the top of both libstdc++ and libc++, we can see that an expression of the form `a < b` is
invalid. MSVC also mentions `std::less<void>`, so we can safely conclude that all three major
implementations of the Standard Library communicate we're falling flat on our faces with a less-than
comparison. Beyond that, there isn't terribly much useful information, and it isn't clear from the
way that it is presented that a lacking `bool operator<(const Foo&, const Foo&)` is the culprit:

1. GCC talks a lot about `{ return *__it1 < *__it2; }`. This snippet of code exposes the
   implementation of `std::sort` to users. Users shouldn't be concerned with a correct
   implementation of `std::sort`; they should be focusing on the contract that they've ignored.
2. LLVM is exempt, its diagnostic is rather clear.
3. MSVC's diagnostics are less clear, but with some squinting, we can see that they are related to
   `Foo`.

The Ranges TS provides vastly different output. The most relevant part of the diagnostic is

```
  concept bool Sortable =
  concept bool IndirectStrictWeakOrder =
  concept bool StrictWeakOrder =
  concept bool Relation =
  concept bool StrictWeakOrder =
  concept bool Relation =
  concept bool StrictWeakOrder =
  concept bool Relation =
  concept bool StrictWeakOrder =
  concept bool Relation =
  concept bool StrictWeakOrder =
  concept bool Relation =
```

To understand what is happening here, we need to understand what it means to be `Sortable`, what a
`StrictWeakOrder` is, and what a `Relation` is. We can look to mathematics for the definition of
both a relation[3][4] and a strict weak order[5][6]. (We discuss `Sortable` in detail later).
`StrictWeakOrder` is also known as the
[`Compare` concept](http://en.cppreference.com/w/cpp/concept/Compare) in the C++ Standard Library.

While it requires programmers to know more terms, these terms remain consistent with the C++
Standard, as opposed to the diagnostics returned from something such as `std::sort`, which may vary
from implementation to implementation.

## Generic programming with Concepts

It has been argued that real-world concepts, such as `Sortable`, are difficult to understand. This
is correct. I do not expect the authors of the Palo Alto TR, nor the authors of the Ranges TS to
disagree either. The mathematics involved is complex and took years to correctly derive (the Palo
Alto TR was published in 2012; the Ranges TS in 2017). The algebra required to employ Standard
algorithms is present regardless of them using concepts -- wildly incorrect code will still violate
the contract, and well-specified concepts can help to _enforce_ said contract.

What the Ranges TS does is provide a _formal_ way for compilers (and other tools) to check if a type
can be sorted, and _clearly_ communicate the requirements of an interface to users. Someone needs to
write `Sortable` -- in fact, it took at least two people to define this, possibly more -- which
means that it's not a trivial requirement to properly pin down. Leaving this in the hands of the
average programmer is not advisable.

Concepts should not be _written_ by average programmers: they only need to _use_ concepts to reap
the benefits of such complex code. A textbook or reference might summarise `Sortable` as

> An iterator is `Sortable` if, and only if, it is mutable and its `value_type` is both `Movable`
and has a strict weak ordering imposed on it.

The terms "mutable", `Movable`, and "strict weak ordering" are all fairly simple to communicate, and
would ideally be introduced well before the definition of the term `Sortable` in a well-designed
course or textbook.

----------------------------------------------------------------------------------------------------

One might wonder if concepts are simple to compose for experts. Again, they are not, and should
not be trivially composable. A descriptive concept isn't written for trivial things such as
`Addable`, `Subtractable`, etc.: `Sortable` aims to mathematically capture the definition of a
sortable type. Spending five years on modelling the requirements for the Standard Library implicitly
suggests that concepts _should not_ be an easy pass.

This demonstrates that even experts shouldn't be writing concepts on their own. They can use them,
knowing that once they've been thoroughly vetted, the code is guaranteed to block things that
shouldn't be used as parameters.

## Generic programming in C++17

Modern C++ offers various tools for expressive generic programming, and some people wonder if these
make concepts redundant. We'll consider them in turn.

1. `std::enable_if`
2. Tag dispatching
3. `constexpr`-`if` statements
4. `constexpr bool`

### `std::enable_if`

`enable_if` is a hacky way to implement concepts at best. `enable_if<Condition, T>` will have a
member alias called `type` if, and only if, `Condition` evaluates to `true`. This provides a way to
leverage SFINAE to conditionally disable template specialisations and overloads. However,
diagnostics will range from [overload resolution failures](https://godbolt.org/g/HVVBwK) to
[incomplete type errors](https://godbolt.org/g/HLyGWy) none of which provide information of _why_
there was a failure.

Concepts, on the other hand, offer a robust mechanism for detecting which requirement isn't
satisfied. This is likely due to the fact that it is a first-class, core language feature. Another
bonus is that it explicitly communicates that a constraint hasn't been satisfied -- something that
is not made clear by our `enable_if` hack!

This can be demonstrated by taking a look at the diagnostics from the following examples.

#### Not `EqualityComparable`

* Listing 5. [Without concepts](https://godbolt.org/g/BDxLaT)

```cpp
#include <regex>
#include <type_traits>

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<std::regex>, std::regex> foo{};
}
```

* Listing 6. [With concepts](https://godbolt.org/g/WEUwLa)

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

int main()
{
  Regular foo = std::regex{};
}
```

While it's is possible to work out that `std::regex` isn't `EqualityComparable` when using GCC
(without concepts), it isn't nearly as clear as the concept-equivalent GCC implementation. There are
considerable more diagnostics to decipher, and GCC sells the idea that the problem lies with the
definition of `EqualityComparable`, instead of directing the programmer to understand that
`std::regex` fails to meet the requirements of `Regular`, because it fails to meet the requirements
outlined by `EqualityComparable`.

MSVC identifies that `std::regex` doesn't have an `operator==`, nor an `operator!=`, but it also
spits out a lot of spurious and irrelevant diagnostics.

Clang offers the best non-concept-diagnostics. It also sells the idea that there is a problem with
`EqualityComparable`, but words it in such a way that with experience, one can be able to discern
what is happening. The biggest issue is that it reports the error in reverse -- something that
Concepts fixes.

#### Not `DefaultConstructible`

* Listing 7. [Without concepts](https://godbolt.org/g/LFa394)

```cpp
#include <regex>
#include <type_traits>

class Foo {
public:
  Foo() = delete; 
};

constexpr bool operator==(const Foo, const Foo) noexcept;
constexpr bool operator!=(const Foo, const Foo) noexcept;

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
}
```

* Listing 8. [With concepts](https://godbolt.org/g/Vo7Ati)

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

class Foo {
public:
  Foo() = delete; 
};

constexpr bool operator==(const Foo, const Foo) noexcept;
constexpr bool operator!=(const Foo, const Foo) noexcept;

int main()
{
  Regular foo = Foo{};
}
```

This is a fairly open-shut case. None of the Concepts-absent compilers report that `Foo` is not a
`Regular` type because it is not `DefaultConstructible`. The Concepts-enabled GCC implementation
does.

#### Not `DefaultConstructible` and not `Copyable`

* Listing 9. [Without concepts](https://godbolt.org/g/w755Nh)

```cpp
#include <regex>
#include <type_traits>

class Foo {
public:
  Foo() = delete;
  Foo(const Foo&) = delete;
};

constexpr bool operator==(const Foo&, const Foo&) noexcept;
constexpr bool operator!=(const Foo&, const Foo&) noexcept;

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
}
```

* Listing 10. [With concepts](https://godbolt.org/g/17V9A1)

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

class Foo {
public:
  Foo() = delete;
  Foo(const Foo&) = delete;
};

constexpr bool operator==(const Foo&, const Foo&) noexcept;
constexpr bool operator!=(const Foo&, const Foo&) noexcept;

int main()
{
  Regular foo = Foo{};
}
```

Again, non-Concepts compilers don't identify why the code is ill-formed. There are a lot of
diagnostics from the Concepts-enabled GCC -- perhaps this can be worked on, but at least it
identifies the problem.

### Tag dispatching

* Listing 11. [Without concepts](https://godbolt.org/g/HhzSrc)

```cpp
#include <iterator>

template <typename I>
void advance_helper(I i, typename std::iterator_traits<I>::difference_type n, std::random_access_iterator_tag)
{
   i += n;
}

template <typename I>
void advance_helper(I i, typename std::iterator_traits<I>::difference_type n, std::bidirectional_iterator_tag)
{
   for (; n > 0; --n)
      ++i;
   for (; n < 0; ++n)
      --i;
}

template <typename I>
void advance_helper(I i, typename std::iterator_traits<I>::difference_type n, std::input_iterator_tag)
{
   for (; n > 0; --n)
      ++i;
}

template <typename I>
void advance(I i, typename std::iterator_traits<I>::difference_type n)
{
   advance_helper(i, n, typename std::iterator_traits<I>::iterator_category{});
}
```

* Listing 12. [With concepts](https://godbolt.org/g/rdxueA)

```cpp
#include <experimental/ranges/iterator>

namespace ranges = std::experimental::ranges;

template <ranges::RandomAccessIterator I>
void advance_helper(I i, ranges::difference_type_t<I> n)
{
   i += n;
}

template <ranges::BidirectionalIterator I>
void advance_helper(I i, ranges::difference_type_t<I> n)
{
   for (; n > 0; --n)
      ++i;
   for (; n < 0; ++n)
      --i;
}

template <ranges::InputIterator I>
void advance_helper(I i, ranges::difference_type_t<I> n)
{
   for (; n > 0; --n)
      ++i;
}

template <typename I>
void advance(I i, ranges::difference_type_t<I> n)
{
   advance_helper(i, n);
}
```

Listing 11 is a slightly modified version of this example implementation[7] of `std::advance` to
illustrate type traits. This isn't exactly complex code, but it is clunky, and it's possible to
trick the compiler into thinking that we have a tag that we don't really have. It is also very
awkward to call this function: we need to define an object that doesn't really serve any purpose
other than to tell the compiler "call this function".

Listing 12 eliminates all of these problems. It clearly states what the requirements are in the
template header and makes it considerably harder to trick the compiler. Furthermore, we don't need
to have a tag to say "call me!". This makes _using_ constrained functions simpler than their
tag-counterparts.

### `constexpr`-`if` statements

* Listing 13. [Replacing concepts with `constexpr if`](https://godbolt.org/g/dBCJtT)

```cpp
#include <experimental/ranges/iterator>

namespace ranges = std::experimental::ranges;

template <typename I>
void advance(I i, ranges::difference_type_t<I> n)
{
   if constexpr (ranges::RandomAccessIterator<I>) {
      i += n;
   }
   else if constexpr (ranges::BidirectionalIterator<I>) {
    for (; n > 0; --n)
       ++i;
    for (; n < 0; ++n)
       --i;
   }
   else {
      for (; n > 0; --n)
         ++i;
   }
}
```

* Listing 14. [Appropriate use of `constexpr if`](https://godbolt.org/g/9B4NTz)

```cpp
#include <experimental/ranges/concepts>
#include <fstream>
#include <string>
#include <deque>

namespace ranges = std::experimental::ranges;

template <template <typename...> typename C, typename T>
C<T> from_file(const std::string& path)
{
   if (auto in = std::ifstream{path}) {
      const ranges::SignedIntegral size = [&in]{
         ranges::SignedIntegral i = 0;
         in >> i;
         return i;
      }();

      auto c = [size]{
         auto c = C<T>{};
         if constexpr (std::is_same_v<C<T>, std::vector<T>>)
            c.reserve(size);
         return c;
      }();
      // ...

      return c;
   }
}

int main()
{
    from_file<std::vector, int>("foo");
}
```

`constexpr`-`if` statements are a great way to eliminate SFINAE, as are Concepts. One might argue
that the above program could also be written as it is in Listing 13. This is terrible design. We
have combined three different functions, which articulate three different forms of logic, into a
single function that operates on `if`-statements.

`constexpr if`-statements are a powerful tool, that when used correctly, are a great way for
avoiding nasty and obscure SFINAE. This is great in small doses, but it isn't viable for something
where lots of specialised logic is present, or the logic for a specialisation is independent to
another specialisation.

An example of what constitutes as a 'valid' use of `constexpr if` might look like Listing 14. Note
that this is both a contrived and simple approach: a more detailed use-case can be found in the
`accessor` tests for the SYCL 1.2.1 CTS.

The point of this contrived example is to show that `if constexpr` is used to complement the
function: not to completely switch behaviour on a different type, as is demonstrated in the
`advance` port.

This is an example of separating interfaces from implementations. Listing 13 confuses the boundary
between the interface and the implementation that is very clearly provided in Lisiting 12. Listing
14 does no such thing -- enables one features that are very specific to `std::vector`, but it in no
way alters the bulk of the algorithm if we choose to use `std::deque` instead.

### `constexpr bool` objects

Some might argue that the constrained variable declaration syntax can already be achieved by
templated `constexpr bool` objects. For an example, simply visit any of the links to Compiler
Explorer for a non-Concepts-enabled example.

When using them with `enable_if`, they choke out the ability to use automatic type deduction:
perhaps we should write code like so:

```cpp
auto v = std::vector<int>{}; static_assert(Regular<decltype(v)>);
```

Quite frankly, this is far more intrusive than needing to learn about Concepts' constrained variable
syntax, which enables this check, by default; additionally, I wager that it would take a very
dedicated programmer to provide concept checks in such a manner. Then, the code will need to pass a
review, and reviewers mightn't like such code, or understand why it's necessary. Arguing that the
regularity is a part of the type deduction is far simpler, and far more readable.

This also doesn't take contexts where a `static_assert` can't be used directly after the declaration
into consideration. For example, a range-for statement:

```cpp
for (auto i : v) {
  static_assert(Regular<decltype(i)>);
  // ...
}
```

And we haven't looked at reference types. To check that the underlying type of a reference is
regular, we ought to strip the reference part, because `Regular<T&>` doesn't mean the same thing as
`Regular<T>`. To do that, we need to use `std::decay_t`. Or is it `std::remove_reference_t`? What
about when `const` is involved? That's `std::remove_const_t`. Should I just combine all of them
together and hope for the best? Crap, the order matters too.
`std::remove_reference_t<std::remove_const_t<T>>` isn't the same as
`std::remove_const_t<std::remove_reference_t<T>>`. Where does `std::decay` fit in again? Is this
snippet right? Is it _understandable_?

```cpp
for (const auto& i : v) {
   static_assert(Regular<std::remove_const_t<std::remove_reference_t<decltype(i)>>>);
   // ...
}
```

Concepts avoid this issue by going directly to the underlying type, which is checked before the
reference is ever applied. We can use

```cpp
for (const Regular& i : v) {
  // ...
}
```

and _not_ worry about references or `const` types.

Modern C++ programmers shouldn't need to worry about template metaprogramming on a daily basis.
Novices should worry about template metaprogramming even less than average C++ programmers. The
problem is that we thrust template metaprogramming on to non-experts and non-library developers in
contexts that probably do not require such code. Concepts, especially when paired with Ranges, offer
a way to curb high amounts of template metaprogramming. Eric Niebler's
[Range-v3](https://github.com/ericniebler/range-v3/) library offers no such mechanism; it does not
have language support.

## Conclusion

There are arguments that the Concepts TS don't offer anything to simplify generic programming in
C++, but most overlook the fact that the tools we currently have are Hacky-at-Best<sup>TM</sup>.
Arguments made against diagnostics forget that there is only one reference implementation for
Concepts, and that the "complex" diagnostics resulting from said implementation can always be
improved upon.

Concepts do simplify generic programming when used correctly. As someone who works with templates on
a daily basis, tools such as `enable_if` are obscure and tools such as `constexpr if` are not always
the correct answer. To add concepts to the mix is to add:

* a valuable tool that helps reduce the amount of expert-friendly code by banishing complex template
  metaprogramming to concept definitions,
* first-class support for constraint-based type deduction
* offering the opportunity to receive clearer diagnostics
* the choice between `constexpr if` and constrained functions when the situation calls for one or
  the other.

Concepts don't make any of the above features redundant; nor do any of the above features make
Concepts dead-on-arrival. They instead offer programmers the opportunity to choose the correct tool
for the correct problem. Concepts make C++ better.

## Acknowledgements

I would like to thank  Simon Brand, Tom Honermann, Alastair Murray, Ruyman Reyes, Michael Wong, and
Amy Worthington, Peter Žužek for providing their feedback on this paper.

Thank you to Michael for presenting to EWG.

## References

1. _Relation (mathematics)_. Date retrieved: 2017-10-06 16:59. Retrieved from:
   [https://simple.wikipedia.org/wiki/Relation_(mathematics)](https://simple.wikipedia.org/wiki/Relation_(mathematics)).
2. _Weak ordering_. Date retrieved: 2017-10-06 17:02. Retrieved from:
   [https://en.wikipedia.org/wiki/Weak_ordering](https://en.wikipedia.org/wiki/Weak_ordering).
3. Alexandrescu, A. _There's Treasure Everywhere_. ACCU. Delivered 2016-04-21. Published 2016-05-16.
   Date retrieved: 2017-16-10. Retrieved from: [https://youtu.be/AxnotgLql0k](https://youtu.be/AxnotgLql0k).
4. Exon Smith, D. _P0726R0 Does the Concepts TS Improve on C++17?_. 2017-07-07. Retrieved from:
   www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0726r0.html.
5. Honermann, T. _Refining Concepts: Improving error messages_. 2016-07-18. Date retrieved:
   2017-10-16. Retrieved from:
   [http://honermann.net/blog/2016/07/18/refining-concepts-improving-error-messages](http://honermann.net/blog/2016/07/18/refining-concepts-improving-error-messages).
6. Muller, J. _Implementation Challenge: Concepts in C++14_. 2017-09-09. Date retrieved: 2017-10-12.
   Retrieved from: [http://foonathan.net/blog/2016/09/09/cpp14-concepts.html](http://foonathan.net/blog/2016/09/09/cpp14-concepts.html).
7. Stroustrup, B. _The C++ Programming Language_. Fourth edition. 2013.
   Addison-Wesley. Upper Saddle River, NJ.
8. Voutilainen, V. _P0225R0 Why I want Concepts, and why I want them sooner rather than later_.
   International Organization for Standardization. 2016-02-05. Date retrieved: 2017-10-16.
   Retrieved from: [http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html](http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html).
9. Wolfram MathWorld. _Relation_. Date retrieved: 2017-10-06. Retrieved from:
   [http://mathworld.wolfram.com/Relation.html](http://mathworld.wolfram.com/Relation.html).
10. Wolfram MathWorld. _Strict Order_. Date retrieved: 2017-10-06. Retrieved from:
    [http://mathworld.wolfram.com/StrictOrder.html](http://mathworld.wolfram.com/StrictOrder.html).


## Appendix A

1. [Listing 1](#listing-1)
  1. [Source](#source)
  2. [GCC diagnostic](#gcc-diagnostic)
  3. [Clang diagnostic](#clang-diagnostic)
  4. [MSVC diagnostic](#msvc-diagnostic)

2. [Listing 2](#listing-2)
  1. [Source](#source-1)
  2. [GCC diagnostic](#gcc-diagnostic-1)

3. [Listing 3](#listing-3)
  1. [Source](#source-2)
  2. [GCC diagnostic](#gcc-diagnostic-2)
  3. [Clang diagnostic](#clang-diagnostic-1)
  4. [MSVC diagnostic](#msvc-diagnostic-1)

4. [Listing 4](#listing-4)
  1. [Source](#source-3)
  2. [GCC diagnostic](#gcc-diagnostic-3)

5. [Listing 5](#listing-5)
  1. [Source](#source-4)
  2. [GCC diagnostic](#gcc-diagnostic-4)
  3. [Clang diagnostic](#clang-diagnostic-2)
  4. [MSVC diagnostic](#msvc-diagnostic-2)

6. [Listing 6](#listing-6)
  1. [Source](#source-5)
  2. [GCC diagnostic](#gcc-diagnostic-5)

7. [Listing 7](#listing-7)
  1. [Source](#source-6)
  2. [GCC diagnostic](#gcc-diagnostic-6)
  3. [Clang diagnostic](#clang-diagnostic-3)
  4. [MSVC diagnostic](#msvc-diagnostic-3)

8. [Listing 8](#listing-8)
  1. [Source](#source-7)
  2. [GCC diagnostic](#gcc-diagnostic-7)

9. [Listing 9](#listing-9)
  1. [Source](#source-8)
  2. [GCC diagnostic](#gcc-diagnostic-8)
  3. [Clang diagnostic](#clang-diagnostic-4)
  4. [MSVC diagnostic](#msvc-diagnostic-4)

10. [Listing 10](#listing-10)
  1. [Source](#source-9)
  2. [GCC diagnostic](#gcc-diagnostic-9)

### Listing 1
#### Source

```cpp
#include <algorithm>
#include <iterator>
#include <list>

int main()
{
  auto l = std::list{1, 2, 3, 4, 5};
  std::sort(std::begin(l), std::end(l));
}
```

#### GCC diagnostic

```
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h: In instantiation of 'void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = std::_List_iterator<int>; _Compare = __gnu_cxx::__ops::_Iter_less_iter]':
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:4836:18:   required from 'void std::sort(_RAIter, _RAIter) [with _RAIter = std::_List_iterator<int>]'
8 : <source>:8:39:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1969:22: error: no match for 'operator-' (operand types are 'std::_List_iterator<int>' and 'std::_List_iterator<int>')
     std::__lg(__last - __first) * 2,
               ~~~~~~~^~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:389:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator-(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:389:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1969:22: note:   'std::_List_iterator<int>' is not derived from 'const std::reverse_iterator<_Iterator>'
     std::__lg(__last - __first) * 2,
               ~~~~~~~^~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1191:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator-(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1191:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1969:22: note:   'std::_List_iterator<int>' is not derived from 'const std::move_iterator<_IteratorL>'
     std::__lg(__last - __first) * 2,
               ~~~~~~~^~~~~~~~~
Compiler exited with result code 1
```

#### Clang diagnostic

```
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4007:40: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'std::__1::__list_iterator<int, void *>')
        difference_type __len = __last - __first;
                                ~~~~~~ ^ ~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<int, int> &, std::__1::__list_iterator<int, void *> >' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<std::__1::__list_iterator<int, void *>, std::__1::__less<int, int> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
8 : <source>:8:8: note: in instantiation of function template specialization 'std::__1::sort<std::__1::__list_iterator<int, void *> >' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:747:1: note: candidate template ignored: could not match 'reverse_iterator' against '__list_iterator'
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1166:1: note: candidate template ignored: could not match 'move_iterator' against '__list_iterator'
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1571:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4098:33: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'std::__1::__list_iterator<int, void *>')
                        if (__i >= __j)
                            ~~~ ^  ~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/utility:583:1: note: candidate template ignored: could not match 'pair' against '__list_iterator'
operator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:730:1: note: candidate template ignored: could not match 'reverse_iterator' against '__list_iterator'
operator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1149:1: note: candidate template ignored: could not match 'move_iterator' against '__list_iterator'
operator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1522:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1554:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT_DEBUG
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/tuple:1203:1: note: candidate template ignored: could not match 'tuple' against '__list_iterator'
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2889:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2976:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2984:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4721:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4809:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4817:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/list:2396:1: note: candidate template ignored: could not match 'list' against '__list_iterator'
operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4122:17: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'std::__1::__list_iterator<int, void *>')
        if (__i < __j)
            ~~~ ^ ~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/utility:567:1: note: candidate template ignored: could not match 'pair' against '__list_iterator'
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:706:1: note: candidate template ignored: could not match 'reverse_iterator' against '__list_iterator'
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1125:1: note: candidate template ignored: could not match 'move_iterator' against '__list_iterator'
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1494:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/tuple:1187:1: note: candidate template ignored: could not match 'tuple' against '__list_iterator'
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2868:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2926:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2935:1: note: candidate template ignored: could not match 'unique_ptr' against '__list_iterator'
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4696:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4761:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4769:1: note: candidate template ignored: could not match 'shared_ptr' against '__list_iterator'
operator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/list:2372:1: note: candidate template ignored: could not match 'list' against '__list_iterator'
operator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4156:65: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'int')
            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))
                                                             ~~~^~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:765:1: note: candidate template ignored: could not match 'reverse_iterator<type-parameter-0-0>' against 'int'
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1184:1: note: candidate template ignored: could not match 'move_iterator<type-parameter-0-0>' against 'int'
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1597:1: note: candidate template ignored: could not match '__wrap_iter<type-parameter-0-0>' against 'int'
operator+(typename __wrap_iter<_Iter>::difference_type __n,
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4173:17: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'std::__1::__list_iterator<int, void *>')
        if (__i - __first < __last - __i)
            ~~~ ^ ~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:747:1: note: candidate template ignored: could not match 'reverse_iterator' against '__list_iterator'
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1166:1: note: candidate template ignored: could not match 'move_iterator' against '__list_iterator'
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1571:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3915:20: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'std::__1::__list_iterator<int, void *>')
    switch (__last - __first)
            ~~~~~~ ^ ~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4155:32: note: in instantiation of function template specialization 'std::__1::__insertion_sort_incomplete<std::__1::__less<int, int> &, std::__1::__list_iterator<int, void *> >' requested here
            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
                               ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<int, int> &, std::__1::__list_iterator<int, void *> >' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<std::__1::__list_iterator<int, void *>, std::__1::__less<int, int> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
8 : <source>:8:8: note: in instantiation of function template specialization 'std::__1::sort<std::__1::__list_iterator<int, void *> >' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:747:1: note: candidate template ignored: could not match 'reverse_iterator' against '__list_iterator'
operator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1166:1: note: candidate template ignored: could not match 'move_iterator' against '__list_iterator'
operator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1571:1: note: candidate template ignored: could not match '__wrap_iter' against '__list_iterator'
operator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3935:40: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'int')
    _RandomAccessIterator __j = __first+2;
                                ~~~~~~~^~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:765:1: note: candidate template ignored: could not match 'reverse_iterator<type-parameter-0-0>' against 'int'
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1184:1: note: candidate template ignored: could not match 'move_iterator<type-parameter-0-0>' against 'int'
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1597:1: note: candidate template ignored: could not match '__wrap_iter<type-parameter-0-0>' against 'int'
operator+(typename __wrap_iter<_Iter>::difference_type __n,
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3936:39: error: invalid operands to binary expression ('std::__1::__list_iterator<int, void *>' and 'int')
    __sort3<_Compare>(__first, __first+1, __j, __comp);
                               ~~~~~~~^~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:765:1: note: candidate template ignored: could not match 'reverse_iterator<type-parameter-0-0>' against 'int'
operator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1184:1: note: candidate template ignored: could not match 'move_iterator<type-parameter-0-0>' against 'int'
operator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1597:1: note: candidate template ignored: could not match '__wrap_iter<type-parameter-0-0>' against 'int'
operator+(typename __wrap_iter<_Iter>::difference_type __n,
^
8 errors generated.
Compiler exited with result code 1
```

#### MSVC diagnostic

```
example.cpp
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
7 : <source>(7): error C2955: 'std::list': use of class template requires template argument list
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/list(879): note: see declaration of 'std::list'
8 : <source>(8): error C3536: 'l': cannot be used before it is initialized
8 : <source>(8): error C2672: 'std::begin': no matching overloaded function found
8 : <source>(8): error C2893: Failed to specialize function template 'unknown-type std::begin(_Container &)'
8 : <source>(8): note: With the following template arguments:
8 : <source>(8): note: '_Container=int'
8 : <source>(8): error C2784: 'const _Elem *std::begin(std::initializer_list<_Elem>) noexcept': could not deduce template argument for 'std::initializer_list<_Elem>' from 'int'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/initializer_list(61): note: see declaration of 'std::begin'
8 : <source>(8): error C2672: 'std::end': no matching overloaded function found
8 : <source>(8): error C2893: Failed to specialize function template 'unknown-type std::end(_Container &)'
8 : <source>(8): note: With the following template arguments:
8 : <source>(8): note: '_Container=int'
8 : <source>(8): error C2784: 'const _Elem *std::end(std::initializer_list<_Elem>) noexcept': could not deduce template argument for 'std::initializer_list<_Elem>' from 'int'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/initializer_list(68): note: see declaration of 'std::end'
8 : <source>(8): error C2672: 'std::sort': no matching overloaded function found
8 : <source>(8): error C2780: 'void std::sort(_RanIt,_RanIt)': expects 2 arguments - 1 provided
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2921): note: see declaration of 'std::sort'
8 : <source>(8): error C2780: 'void std::sort(_RanIt,_RanIt,_Pr)': expects 3 arguments - 1 provided
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2913): note: see declaration of 'std::sort'
Microsoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.
Compiler exited with result code 2
```

### Listing 2

#### Source

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <list>

namespace ranges = std::experimental::ranges;

int main()
{
  auto l = std::list{1, 2, 3, 4, 5};
  ranges::sort(ranges::begin(l), ranges::end(l));
}
```

#### GCC diagnostic

```
<source>: In function 'int main()':
10 : <source>:10:48: error: no matching function for call to 'sort(std::_List_iterator<int>, std::_List_iterator<int>)'
   ranges::sort(ranges::begin(l), ranges::end(l));
                                                ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:90:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:31:4: note: candidate: I std::experimental::ranges::v1::sort(I, S, Comp, Proj) [with I = std::_List_iterator<int>; S = std::_List_iterator<int>; Comp = std::experimental::ranges::v1::less<void>; Proj = std::experimental::ranges::v1::identity]
  I sort(I first, S sent, Comp comp = Comp{}, Proj proj = Proj{})
    ^~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:31:4: note:   constraints not satisfied
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/basic_iterator.hpp:23:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/any_iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:17,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:652:15: note: within 'template<class I> concept const bool std::experimental::ranges::v1::RandomAccessIterator<I> [with I = std::_List_iterator<int>]'
  concept bool RandomAccessIterator =
               ^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:76:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::DerivedFrom<T, U> [with T = std::experimental::ranges::v1::bidirectional_iterator_tag; U = std::experimental::ranges::v1::random_access_iterator_tag]'
  concept bool DerivedFrom =
               ^~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:76:15: note:   'std::experimental::ranges::v1::random_access_iterator_tag' is not a base of 'std::experimental::ranges::v1::bidirectional_iterator_tag'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:76:15: note: 'std::is_convertible<std::experimental::ranges::v1::bidirectional_iterator_tag*, std::experimental::ranges::v1::random_access_iterator_tag*>::value' evaluated to false
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/basic_iterator.hpp:23:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/any_iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:17,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:545:15: note: within 'template<class S, class I> concept const bool std::experimental::ranges::v1::SizedSentinel<S, I> [with S = std::_List_iterator<int>; I = std::_List_iterator<int>]'
  concept bool SizedSentinel =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:545:15: note:     with 'const std::_List_iterator<int> i'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:545:15: note:     with 'const std::_List_iterator<int> s'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:545:15: note: the required expression '(s - i)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:545:15: note: the required expression '(i - s)' would be ill-formed
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:17:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:140:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::StrictTotallyOrdered<T> [with T = std::_List_iterator<int>]'
  concept bool StrictTotallyOrdered =
               ^~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::__totally_ordered<T, U> [with T = std::_List_iterator<int>; U = std::_List_iterator<int>]'
  concept bool __totally_ordered =
               ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note:     with 'std::remove_reference_t<std::_List_iterator<int> >& t'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note:     with 'std::remove_reference_t<std::_List_iterator<int> >& u'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note: the required expression '(t < u)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note: the required expression '(t > u)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note: the required expression '(t <= u)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:125:15: note: the required expression '(t >= u)' would be ill-formed
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:27:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/basic_iterator.hpp:23,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/any_iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:17,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: within 'template<class I> concept const bool std::experimental::ranges::v1::ext::RandomAccessIncrementable<I> [with I = std::_List_iterator<int>]'
   concept bool RandomAccessIncrementable =
                ^~~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note:     with 'std::_List_iterator<int>& i'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note:     with 'const std::_List_iterator<int>& ci'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note:     with 'std::experimental::ranges::v1::difference_type_t<std::_List_iterator<int> > n'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression 'i += n' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression 'i -= n' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression '(ci + n)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression '(n + ci)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression '(ci - n)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/increment.hpp:138:16: note: the required expression '(ci - ci)' would be ill-formed
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/basic_iterator.hpp:23:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/any_iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/iterator.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:17,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:652:15: note:     with 'const std::_List_iterator<int>& ci'
  concept bool RandomAccessIterator =
               ^~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:652:15: note:     with 'std::experimental::ranges::v1::difference_type_t<std::_List_iterator<int> > n'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/iterator/concepts.hpp:652:15: note: the required expression 'ci[n]' would be ill-formed
10 : <source>:10:48: note: ill-formed constraint
   ranges::sort(ranges::begin(l), ranges::end(l));
                                                ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:90:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:46:23: note: candidate: template<class Rng, class Comp, class Proj>  requires  RandomAccessRange<Rng> and Sortable<decltype((std::experimental::ranges::v1::<unnamed>::begin)((declval<R&>)())), Comp, Proj> std::experimental::ranges::v1::safe_iterator_t<Rng> std::experimental::ranges::v1::sort(Rng&&, Comp, Proj)
  safe_iterator_t<Rng> sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{})
                       ^~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:46:23: note:   template argument deduction/substitution failed:
Compiler exited with result code 1
```

### Listing 3

#### Source

```cpp
#include <algorithm>
#include <iterator>
#include <vector>

class Foo {};

int main()
{
  auto l = std::vector<Foo>{};
  std::sort(std::begin(l), std::end(l));
}
```

#### GCC diagnostic

```
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h: In instantiation of 'constexpr bool __gnu_cxx::__ops::_Iter_less_iter::operator()(_Iterator1, _Iterator2) const [with _Iterator1 = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Iterator2 = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >]':
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:81:17:   required from 'void std::__move_median_to_first(_Iterator, _Iterator, _Iterator, _Iterator, _Compare) [with _Iterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1921:34:   required from '_RandomAccessIterator std::__unguarded_partition_pivot(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1953:38:   required from 'void std::__introsort_loop(_RandomAccessIterator, _RandomAccessIterator, _Size, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Size = long int; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1968:25:   required from 'void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:4836:18:   required from 'void std::sort(_RAIter, _RAIter) [with _RAIter = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >]'
10 : <source>:10:39:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:43:23: error: no match for 'operator<' (operand types are 'Foo' and 'Foo')
       { return *__it1 < *__it2; }
                ~~~~~~~^~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:43:23: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_IteratorL, _Container>'
       { return *__it1 < *__it2; }
                ~~~~~~~^~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:43:23: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_Iterator, _Container>'
       { return *__it1 < *__it2; }
                ~~~~~~~^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h: In instantiation of 'bool __gnu_cxx::__ops::_Val_less_iter::operator()(_Value&, _Iterator) const [with _Value = Foo; _Iterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >]':
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1828:20:   required from 'void std::__unguarded_linear_insert(_RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Val_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1855:36:   required from 'void std::__insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1885:25:   required from 'void std::__final_insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1971:31:   required from 'void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:4836:18:   required from 'void std::sort(_RAIter, _RAIter) [with _RAIter = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >]'
10 : <source>:10:39:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:90:22: error: no match for 'operator<' (operand types are 'Foo' and 'Foo')
       { return __val < *__it; }
                ~~~~~~^~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:90:22: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_IteratorL, _Container>'
       { return __val < *__it; }
                ~~~~~~^~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:90:22: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_Iterator, _Container>'
       { return __val < *__it; }
                ~~~~~~^~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h: In instantiation of 'bool __gnu_cxx::__ops::_Iter_less_val::operator()(_Iterator, _Value&) const [with _Iterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Value = Foo]':
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_heap.h:133:48:   required from 'void std::__push_heap(_RandomAccessIterator, _Distance, _Distance, _Tp, _Compare&) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Distance = long int; _Tp = Foo; _Compare = __gnu_cxx::__ops::_Iter_less_val]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_heap.h:237:23:   required from 'void std::__adjust_heap(_RandomAccessIterator, _Distance, _Distance, _Tp, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Distance = long int; _Tp = Foo; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_heap.h:342:22:   required from 'void std::__make_heap(_RandomAccessIterator, _RandomAccessIterator, _Compare&) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1672:23:   required from 'void std::__heap_select(_RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1933:25:   required from 'void std::__partial_sort(_RandomAccessIterator, _RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1948:27:   required from 'void std::__introsort_loop(_RandomAccessIterator, _RandomAccessIterator, _Size, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Size = long int; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:1968:25:   required from 'void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algo.h:4836:18:   required from 'void std::sort(_RAIter, _RAIter) [with _RAIter = __gnu_cxx::__normal_iterator<Foo*, std::vector<Foo> >]'
10 : <source>:10:39:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:65:22: error: no match for 'operator<' (operand types are 'Foo' and 'Foo')
       { return *__it < __val; }
                ~~~~~~^~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note: candidate: template<class _IteratorL, class _IteratorR, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)
     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:888:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:65:22: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_IteratorL, _Container>'
       { return *__it < __val; }
                ~~~~~~^~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note: candidate: template<class _Iterator, class _Container> bool __gnu_cxx::operator<(const __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)
     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:895:5: note:   template argument deduction/substitution failed:
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:71:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/predefined_ops.h:65:22: note:   'Foo' is not derived from 'const __gnu_cxx::__normal_iterator<_Iterator, _Container>'
       { return *__it < __val; }
                ~~~~~~^~~~~~~
Compiler exited with result code 1
```

#### Clang diagnostic

```
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:719:71: error: invalid operands to binary expression ('const Foo' and 'const Foo')
    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}
                                                                  ~~~ ^ ~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4014:17: note: in instantiation of member function 'std::__1::__less<Foo, Foo>::operator()' requested here
            if (__comp(*--__last, *__first))
                ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<Foo, Foo> &, Foo *>' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *, std::__1::__less<Foo, Foo> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4225:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *>' requested here
    _VSTD::sort(__first.base(), __last.base());
           ^
10 : <source>:10:8: note: in instantiation of function template specialization 'std::__1::sort<Foo>' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/utility:567:1: note: candidate template ignored: could not match 'pair<type-parameter-0-0, type-parameter-0-1>' against 'const Foo'
operator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:706:1: note: candidate template ignored: could not match 'reverse_iterator<type-parameter-0-0>' against 'const Foo'
operator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1125:1: note: candidate template ignored: could not match 'move_iterator<type-parameter-0-0>' against 'const Foo'
operator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/iterator:1494:1: note: candidate template ignored: could not match '__wrap_iter<type-parameter-0-0>' against 'const Foo'
operator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT_DEBUG
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/tuple:1187:1: note: candidate template ignored: could not match 'tuple<type-parameter-0-0...>' against 'const Foo'
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2868:1: note: candidate template ignored: could not match 'unique_ptr<type-parameter-0-0, type-parameter-0-1>' against 'const Foo'
operator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2926:1: note: candidate template ignored: could not match 'unique_ptr<type-parameter-0-0, type-parameter-0-1>' against 'const Foo'
operator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:2935:1: note: candidate template ignored: could not match 'unique_ptr<type-parameter-0-0, type-parameter-0-1>' against 'const Foo'
operator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4696:1: note: candidate template ignored: could not match 'shared_ptr<type-parameter-0-0>' against 'const Foo'
operator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4761:1: note: candidate template ignored: could not match 'shared_ptr<type-parameter-0-0>' against 'const Foo'
operator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/memory:4769:1: note: candidate template ignored: could not match 'shared_ptr<type-parameter-0-0>' against 'const Foo'
operator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT
^
In file included from <source>:1:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3801:20: error: no matching function for call to '__sort3'
    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
                   ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4021:20: note: in instantiation of function template specialization 'std::__1::__sort4<std::__1::__less<Foo, Foo> &, Foo *>' requested here
            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
                   ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<Foo, Foo> &, Foo *>' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *, std::__1::__less<Foo, Foo> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4225:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *>' requested here
    _VSTD::sort(__first.base(), __last.base());
           ^
10 : <source>:10:8: note: in instantiation of function template specialization 'std::__1::sort<Foo>' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3761:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3827:20: error: no matching function for call to '__sort4'
    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
                   ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4024:20: note: in instantiation of function template specialization 'std::__1::__sort5<std::__1::__less<Foo, Foo> &, Foo *>' requested here
            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
                   ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<Foo, Foo> &, Foo *>' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *, std::__1::__less<Foo, Foo> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4225:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *>' requested here
    _VSTD::sort(__first.base(), __last.base());
           ^
10 : <source>:10:8: note: in instantiation of function template specialization 'std::__1::sort<Foo>' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3798:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3892:5: error: no matching function for call to '__sort3'
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4029:20: note: in instantiation of function template specialization 'std::__1::__insertion_sort_3<std::__1::__less<Foo, Foo> &, Foo *>' requested here
            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);
                   ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<Foo, Foo> &, Foo *>' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *, std::__1::__less<Foo, Foo> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4225:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *>' requested here
    _VSTD::sort(__first.base(), __last.base());
           ^
10 : <source>:10:8: note: in instantiation of function template specialization 'std::__1::sort<Foo>' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3761:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3925:9: error: no matching function for call to '__sort3'
        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);
        ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/__config:441:15: note: expanded from macro '_VSTD'
#define _VSTD std::_LIBCPP_NAMESPACE
              ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4155:32: note: in instantiation of function template specialization 'std::__1::__insertion_sort_incomplete<std::__1::__less<Foo, Foo> &, Foo *>' requested here
            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
                               ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4200:5: note: in instantiation of function template specialization 'std::__1::__sort<std::__1::__less<Foo, Foo> &, Foo *>' requested here
    __sort<_Comp_ref>(__first, __last, __comp);
    ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4209:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *, std::__1::__less<Foo, Foo> >' requested here
    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
           ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:4225:12: note: in instantiation of function template specialization 'std::__1::sort<Foo *>' requested here
    _VSTD::sort(__first.base(), __last.base());
           ^
10 : <source>:10:8: note: in instantiation of function template specialization 'std::__1::sort<Foo>' requested here
  std::sort(std::begin(l), std::end(l));
       ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3761:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3928:9: error: no matching function for call to '__sort4'
        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);
        ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/__config:441:15: note: expanded from macro '_VSTD'
#define _VSTD std::_LIBCPP_NAMESPACE
              ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3798:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3931:9: error: no matching function for call to '__sort5'
        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);
        ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/__config:441:15: note: expanded from macro '_VSTD'
#define _VSTD std::_LIBCPP_NAMESPACE
              ^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3824:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
^
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3936:5: error: no matching function for call to '__sort3'
    __sort3<_Compare>(__first, __first+1, __j, __comp);
    ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/algorithm:3761:1: note: candidate template ignored: substitution failure [with _Compare = std::__1::__less<Foo, Foo> &, _ForwardIterator = Foo *]
__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)
^
8 errors generated.
Compiler exited with result code 1
```

#### MSVC diagnostic

```
example.cpp
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2823): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2880): note: see reference to function template instantiation 'std::pair<_RanIt,_RanIt> std::_Partition_by_median_guess_unchecked<_RanIt,_Pr>(_RanIt,_RanIt,_Pr &)' being compiled
        with
        [
            _RanIt=Foo *,
            _Pr=std::less<void>
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2908): note: see reference to function template instantiation 'void std::_Sort_unchecked1<_RanIt,__int64,_Pr>(_RanIt,_RanIt,_Diff,_Pr &)' being compiled
        with
        [
            _RanIt=Foo *,
            _Pr=std::less<void>,
            _Diff=__int64
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2916): note: see reference to function template instantiation 'void std::_Sort_unchecked<Foo*,_Pr>(_RanIt,_RanIt,_Pr &)' being compiled
        with
        [
            _Pr=std::less<void>,
            _RanIt=Foo *
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2923): note: see reference to function template instantiation 'void std::sort<_RanIt,std::less<void>>(_RanIt,_RanIt,_Pr)' being compiled
        with
        [
            _RanIt=std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Foo>>>,
            _Pr=std::less<void>
        ]
10 : <source>(10): note: see reference to function template instantiation 'void std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Foo>>>>(_RanIt,_RanIt)' being compiled
        with
        [
            _RanIt=std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Foo>>>
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2823): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2823): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2823): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2823): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2824): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2824): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2824): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2824): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2824): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2827): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2827): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2827): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2827): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2827): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2828): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2828): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2828): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2828): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2828): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2837): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2837): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2837): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2837): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2837): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2839): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2839): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2839): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2839): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2839): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2844): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2844): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2844): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2844): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2844): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2846): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2846): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2846): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2846): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2846): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2766): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2901): note: see reference to function template instantiation 'void std::_Insertion_sort_unchecked<_RanIt,_Pr>(_BidIt,_BidIt,_Pr &)' being compiled
        with
        [
            _RanIt=Foo *,
            _Pr=std::less<void>,
            _BidIt=Foo *
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2766): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2766): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2766): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2766): note: '_Ty2=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2774): error C2672: 'operator __surrogate_func': no matching overloaded function found
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2774): error C2893: Failed to specialize function template 'unknown-type std::less<void>::operator ()(_Ty1 &&,_Ty2 &&) const'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2774): note: With the following template arguments:
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2774): note: '_Ty1=Foo &'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/algorithm(2774): note: '_Ty2=Foo &'
Microsoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.
Compiler exited with result code 2
```

### Listing 4

#### Source

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <vector>

namespace ranges = std::experimental::ranges;

class Non_sortable {};

int main()
{
  auto l = std::vector<Non_sortable>{};
  ranges::sort(ranges::begin(l), ranges::end(l));
}
```

#### GCC diagnostic

```
<source>: In function 'int main()':
12 : <source>:12:48: error: no matching function for call to 'sort(__gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >, __gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >)'
   ranges::sort(ranges::begin(l), ranges::end(l));
                                                ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:90:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:31:4: note: candidate: I std::experimental::ranges::v1::sort(I, S, Comp, Proj) [with I = __gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >; S = __gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >; Comp = std::experimental::ranges::v1::less<void>; Proj = std::experimental::ranges::v1::identity]
  I sort(I first, S sent, Comp comp = Comp{}, Proj proj = Proj{})
    ^~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:31:4: note:   constraints not satisfied
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/partition_point.hpp:28:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/lower_bound.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/binary_search.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:21,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/algorithm.hpp:79:15: note: within 'template<class I, class R, class P> concept const bool std::experimental::ranges::v1::Sortable<I, R, P> [with I = __gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >; R = std::experimental::ranges::v1::less<void>; P = std::experimental::ranges::v1::identity]'
  concept bool Sortable =
               ^~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/callable.hpp:187:15: note: within 'template<class F, class I1, class I2> concept const bool std::experimental::ranges::v1::IndirectStrictWeakOrder<F, I1, I2> [with F = std::experimental::ranges::v1::less<void>; I1 = std::experimental::ranges::v1::projected<__gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >, std::experimental::ranges::v1::identity>; I2 = std::experimental::ranges::v1::projected<__gnu_cxx::__normal_iterator<Non_sortable*, std::vector<Non_sortable> >, std::experimental::ranges::v1::identity>]'
  concept bool IndirectStrictWeakOrder =
               ^~~~~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/functional/not_fn.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/functional.hpp:24,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/adjacent_find.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:18,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:103:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::StrictWeakOrder<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool StrictWeakOrder =
               ^~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::Relation<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool Relation =
               ^~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, const Non_sortable&, const Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {const Non_sortable&, const Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:103:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::StrictWeakOrder<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool StrictWeakOrder =
               ^~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::Relation<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool Relation =
               ^~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, const Non_sortable&, const Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {const Non_sortable&, const Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:103:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::StrictWeakOrder<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool StrictWeakOrder =
               ^~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::Relation<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool Relation =
               ^~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, const Non_sortable&, const Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {const Non_sortable&, const Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:103:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::StrictWeakOrder<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool StrictWeakOrder =
               ^~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::Relation<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool Relation =
               ^~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, Non_sortable&, Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {Non_sortable&, Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: in the expansion of concept 'Predicate<std::experimental::ranges::v1::less<void>&, const Non_sortable&, const Non_sortable&>' template<class F, class ... Args> concept const bool std::experimental::ranges::v1::Predicate<F, Args ...> [with F = std::experimental::ranges::v1::less<void>&; Args = {const Non_sortable&, const Non_sortable&}]
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:103:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::StrictWeakOrder<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool StrictWeakOrder =
               ^~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/function.hpp:75:15: note: within 'template<class R, class T, class U> concept const bool std::experimental::ranges::v1::Relation<R, T, U> [with R = std::experimental::ranges::v1::less<void>&; T = Non_sortable&; U = Non_sortable&]'
  concept bool Relation =
               ^~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:90:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:31:4: note: ... and 5 more constraint errors not shown
  I sort(I first, S sent, Comp comp = Comp{}, Proj proj = Proj{})
    ^~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:46:23: note: candidate: template<class Rng, class Comp, class Proj>  requires  RandomAccessRange<Rng> and Sortable<decltype((std::experimental::ranges::v1::<unnamed>::begin)((declval<R&>)())), Comp, Proj> std::experimental::ranges::v1::safe_iterator_t<Rng> std::experimental::ranges::v1::sort(Rng&&, Comp, Proj)
  safe_iterator_t<Rng> sort(Rng&& rng, Comp comp = Comp{}, Proj proj = Proj{})
                       ^~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/sort.hpp:46:23: note:   template argument deduction/substitution failed:
Compiler exited with result code 1
```

### Listing 5

#### Source

```cpp
#include <regex>
#include <type_traits>

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<std::regex>, std::regex> foo{};
}
```

#### GCC diagnostic

```
<source>: In instantiation of 'constexpr const bool EqualityComparable<std::__cxx11::basic_regex<char> >':
24 : <source>:24:44:   required from 'constexpr const bool Regular<std::__cxx11::basic_regex<char> >'
28 : <source>:28:20:   required from here
20 : <source>:20:79: error: no match for 'operator==' (operand types are 'std::__cxx11::basic_regex<char>' and 'std::__cxx11::basic_regex<char>')
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:56:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:770:5: note: candidate: template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t, const std::function<_Res(_ArgTypes ...)>&)
     operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:770:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::function<_Res(_ArgTypes ...)>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:56:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:764:5: note: candidate: template<class _Res, class ... _Args> bool std::operator==(const std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)
     operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:764:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::function<_Res(_ArgTypes ...)>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:62:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_multimap.h:1045:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_multimap.h:1045:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::multimap<_Key, _Tp, _Compare, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:61:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_map.h:1380:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_map.h:1380:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::map<_Key, _Tp, _Compare, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:1533:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator==(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:1533:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:406:5: note: candidate: template<class _Val> bool std::operator==(const std::_Rb_tree_iterator<_Tp>&, const std::_Rb_tree_const_iterator<_Val>&)
     operator==(const _Rb_tree_iterator<_Val>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:406:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Rb_tree_iterator<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:908:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Up>() == declval<_Tp>()))> std::operator==(const _Up&, const std::optional<_Tp>&)
     operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:908:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:902:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Tp>() == declval<_Up>()))> std::operator==(const std::optional<_Tp>&, const _Up&)
     operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:902:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:846:5: note: candidate: template<class _Tp> constexpr bool std::operator==(std::nullopt_t, const std::optional<_Tp>&)
     operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:846:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:841:5: note: candidate: template<class _Tp> constexpr bool std::operator==(const std::optional<_Tp>&, std::nullopt_t)
     operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:841:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:790:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Tp>() == declval<_Up>()))> std::operator==(const std::optional<_Tp>&, const std::optional<_Up>&)
     operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:790:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/vector:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:51,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_vector.h:1596:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator==(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_vector.h:1596:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::vector<_Tp, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:61:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_stack.h:293:5: note: candidate: template<class _Tp, class _Seq> bool std::operator==(const std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)
     operator==(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_stack.h:293:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::stack<_Tp, _Seq>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:2258:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator==(const std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)
     operator==(const deque<_Tp, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:2258:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::deque<_Tp, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:274:5: note: candidate: template<class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)
     operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:274:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Deque_iterator<_Tp, _Ref, _Ptr>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:267:5: note: candidate: template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref, _Ptr>&)
     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:267:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Deque_iterator<_Tp, _Ref, _Ptr>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:378:5: note: candidate: template<class _Tp> bool std::operator==(std::nullptr_t, const std::shared_ptr<_Tp>&)
     operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:378:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:373:5: note: candidate: template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&, std::nullptr_t)
     operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:373:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:368:5: note: candidate: template<class _Tp, class _Up> bool std::operator==(const std::shared_ptr<_Tp>&, const std::shared_ptr<_Up>&)
     operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:368:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1420:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1420:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp, _Lp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1415:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1415:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp, _Lp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1409:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator==(const __shared_ptr<_Tp1, _Lp>& __a,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1409:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp1, _Lp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:694:5: note: candidate: template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:694:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:689:5: note: candidate: template<class _Tp, class _Dp> bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:689:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:683:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator==(const unique_ptr<_Tp, _Dp>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:683:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:37:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:1397:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements ...>&)
     operator==(const tuple<_TElements...>& __t,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:1397:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::tuple<_Tps ...>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:37,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/array:252:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/array:252:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::array<_Tp, _Nm>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:66:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stream_iterator.h:130:5: note: candidate: template<class _Tp, class _CharT, class _Traits, class _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)
     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stream_iterator.h:130:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_facets.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_ios.h:37,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ios:44,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:64,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/streambuf_iterator.h:204:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/streambuf_iterator.h:204:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/ios_base.h:46:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ios:42,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:64,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:311:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_condition&)
   operator==(const error_condition& __lhs,
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:311:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_condition&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:304:3: note: candidate: bool std::operator==(const std::error_condition&, const std::error_code&)
   operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:304:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_condition&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:297:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_condition&)
   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:297:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_code&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:292:3: note: candidate: bool std::operator==(const std::error_code&, const std::error_code&)
   operator==(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:292:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_code&'
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5841:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5841:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5829:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const _CharT* __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5829:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   mismatched types 'const _CharT*' and 'std::__cxx11::basic_regex<char>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5815:5: note: candidate: template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value, bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const std::__cxx11::basic_string<_CharT>&)
     operator==(const basic_string<_CharT>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5815:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::basic_string<_CharT>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5807:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5807:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:461:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(std::__detail::__idt<std::basic_string_view<_CharT, _Traits> >, std::basic_string_view<_CharT, _Traits>)
     operator==(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:461:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:455:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(std::basic_string_view<_CharT, _Traits>, std::__detail::__idt<std::basic_string_view<_CharT, _Traits> >)
     operator==(basic_string_view<_CharT, _Traits> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:455:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:449:5: note: candidate: template<class _CharT, class _Traits> bool std::operator==(std::basic_string_view<_CharT, _Traits>, std::basic_string_view<_CharT, _Traits>)
     operator==(basic_string_view<_CharT, _Traits> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:449:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:152:5: note: candidate: template<class _Tp> bool std::operator==(const std::allocator<_Tp>&, const std::allocator<_Tp>&)
     operator==(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:152:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::allocator<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:146:5: note: candidate: template<class _T1, class _T2> bool std::operator==(const std::allocator<_Tp>&, const std::allocator<_Tp>&)
     operator==(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:146:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::allocator<_Tp>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/char_traits.h:40:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:40,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/postypes.h:216:5: note: candidate: template<class _StateT> bool std::operator==(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/postypes.h:216:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::fpos<_StateT>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1124:5: note: candidate: template<class _Iterator> constexpr bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator==(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1124:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::move_iterator<_IteratorL>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1118:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr bool std::operator==(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator==(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1118:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::move_iterator<_IteratorL>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:337:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator==(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:337:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::reverse_iterator<_Iterator>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:299:5: note: candidate: template<class _Iterator> constexpr bool std::operator==(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator==(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:299:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::reverse_iterator<_Iterator>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/utility:70:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:443:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:443:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::pair<_T1, _T2>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1922:5: note: candidate: template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter, _Alloc>&)
     operator==(const match_results<_Bi_iter, _Alloc>& __m1,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1922:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::match_results<_BiIter, _Alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1403:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)
     operator==(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1403:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1323:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator==(const typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)
     operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1323:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1249:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)
     operator==(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1249:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1175:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator==(const typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)
     operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1175:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1095:5: note: candidate: template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&)
     operator==(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1095:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1015:5: note: candidate: template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)
     operator==(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1015:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:942:5: note: candidate: template<class _BiIter> bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)
     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:942:5: note:   template argument deduction/substitution failed:
20 : <source>:20:79: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
 constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                             ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
21 : <source>:21:46: error: no match for 'operator!=' (operand types are 'std::__cxx11::basic_regex<char>' and 'std::__cxx11::basic_regex<char>')
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:56:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:788:5: note: candidate: template<class _Res, class ... _Args> bool std::operator!=(std::nullptr_t, const std::function<_Res(_ArgTypes ...)>&)
     operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:788:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::function<_Res(_ArgTypes ...)>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:56:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:782:5: note: candidate: template<class _Res, class ... _Args> bool std::operator!=(const std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)
     operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/std_function.h:782:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::function<_Res(_ArgTypes ...)>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:62:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_multimap.h:1069:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator!=(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const std::multimap<_Key, _Tp, _Compare, _Alloc>&)
     operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_multimap.h:1069:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::multimap<_Key, _Tp, _Compare, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:61:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_map.h:1404:5: note: candidate: template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator!=(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare, _Alloc>&)
     operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_map.h:1404:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::map<_Key, _Tp, _Compare, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:1553:5: note: candidate: template<class _Key, class _Val, class _KeyOfValue, class _Compare, class _Alloc> bool std::operator!=(const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&, const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&)
     operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:1553:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:412:5: note: candidate: template<class _Val> bool std::operator!=(const std::_Rb_tree_iterator<_Tp>&, const std::_Rb_tree_const_iterator<_Val>&)
     operator!=(const _Rb_tree_iterator<_Val>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:412:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Rb_tree_iterator<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:920:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Up>() != declval<_Tp>()))> std::operator!=(const _Up&, const std::optional<_Tp>&)
     operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:920:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:914:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Tp>() != declval<_Up>()))> std::operator!=(const std::optional<_Tp>&, const _Up&)
     operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:914:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:856:5: note: candidate: template<class _Tp> constexpr bool std::operator!=(std::nullopt_t, const std::optional<_Tp>&)
     operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:856:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:851:5: note: candidate: template<class _Tp> constexpr bool std::operator!=(const std::optional<_Tp>&, std::nullopt_t)
     operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:851:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/node_handle.h:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_tree.h:72,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/map:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:52,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:799:5: note: candidate: template<class _Tp, class _Up> constexpr std::__optional_relop_t<decltype ((declval<_Tp>() != declval<_Up>()))> std::operator!=(const std::optional<_Tp>&, const std::optional<_Up>&)
     operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/optional:799:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::optional<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/vector:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:51,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_vector.h:1620:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_vector.h:1620:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::vector<_Tp, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:61:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_stack.h:317:5: note: candidate: template<class _Tp, class _Seq> bool std::operator!=(const std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)
     operator!=(const stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_stack.h:317:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::stack<_Tp, _Seq>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:2284:5: note: candidate: template<class _Tp, class _Alloc> bool std::operator!=(const std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)
     operator!=(const deque<_Tp, _Alloc>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:2284:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::deque<_Tp, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:287:5: note: candidate: template<class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR> bool std::operator!=(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)
     operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:287:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Deque_iterator<_Tp, _Ref, _Ptr>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/deque:64:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/stack:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:47,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:280:5: note: candidate: template<class _Tp, class _Ref, class _Ptr> bool std::operator!=(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref, _Ptr>&)
     operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_deque.h:280:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::_Deque_iterator<_Tp, _Ref, _Ptr>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:393:5: note: candidate: template<class _Tp> bool std::operator!=(std::nullptr_t, const std::shared_ptr<_Tp>&)
     operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:393:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:388:5: note: candidate: template<class _Tp> bool std::operator!=(const std::shared_ptr<_Tp>&, std::nullptr_t)
     operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:388:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:383:5: note: candidate: template<class _Tp, class _Up> bool std::operator!=(const std::shared_ptr<_Tp>&, const std::shared_ptr<_Up>&)
     operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::shared_ptr<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1436:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator!=(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)
     operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1436:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp, _Lp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1431:5: note: candidate: template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool std::operator!=(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)
     operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1431:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp, _Lp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr.h:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/memory:81,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:45,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1425:5: note: candidate: template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy _Lp> bool std::operator!=(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2, _Lp>&)
     operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/shared_ptr_base.h:1425:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__shared_ptr<_Tp1, _Lp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:711:5: note: candidate: template<class _Tp, class _Dp> bool std::operator!=(std::nullptr_t, const std::unique_ptr<_Tp, _Dp>&)
     operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:711:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:706:5: note: candidate: template<class _Tp, class _Dp> bool std::operator!=(const std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)
     operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:706:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:700:5: note: candidate: template<class _Tp, class _Dp, class _Up, class _Ep> bool std::operator!=(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up, _Ep>&)
     operator!=(const unique_ptr<_Tp, _Dp>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:700:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::unique_ptr<_Tp, _Dp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:37:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:1423:5: note: candidate: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Tps ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:1423:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::tuple<_Tps ...>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/tuple:39:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/unique_ptr.h:37,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_conv.h:41,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/locale:43,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:44,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/array:257:5: note: candidate: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/array:257:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::array<_Tp, _Nm>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:66:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stream_iterator.h:137:5: note: candidate: template<class _Tp, class _CharT, class _Traits, class _Dist> bool std::operator!=(const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)
     operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stream_iterator.h:137:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/locale_facets.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_ios.h:37,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ios:44,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:64,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/streambuf_iterator.h:210:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::istreambuf_iterator<_CharT, _Traits>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/ios_base.h:46:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ios:42,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/iterator:64,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:43,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:331:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_condition&)
   operator!=(const error_condition& __lhs,
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:331:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_condition&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:327:3: note: candidate: bool std::operator!=(const std::error_condition&, const std::error_code&)
   operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:327:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_condition&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:323:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_condition&)
   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:323:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_code&'
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:319:3: note: candidate: bool std::operator!=(const std::error_code&, const std::error_code&)
   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
   ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/system_error:319:3: note:   no known conversion for argument 1 from 'std::__cxx11::basic_regex<char>' to 'const std::error_code&'
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5879:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5879:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5867:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5867:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   mismatched types 'const _CharT*' and 'std::__cxx11::basic_regex<char>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5854:5: note: candidate: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:5854:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:479:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(std::__detail::__idt<std::basic_string_view<_CharT, _Traits> >, std::basic_string_view<_CharT, _Traits>)
     operator!=(__detail::__idt<basic_string_view<_CharT, _Traits>> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:479:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:473:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(std::basic_string_view<_CharT, _Traits>, std::__detail::__idt<std::basic_string_view<_CharT, _Traits> >)
     operator!=(basic_string_view<_CharT, _Traits> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:473:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/basic_string.h:48:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:52,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:467:5: note: candidate: template<class _CharT, class _Traits> bool std::operator!=(std::basic_string_view<_CharT, _Traits>, std::basic_string_view<_CharT, _Traits>)
     operator!=(basic_string_view<_CharT, _Traits> __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string_view:467:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::basic_string_view<_CharT, _Traits>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:164:5: note: candidate: template<class _Tp> bool std::operator!=(const std::allocator<_Tp>&, const std::allocator<_Tp>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:164:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::allocator<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:41:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:158:5: note: candidate: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_Tp>&, const std::allocator<_Tp>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/allocator.h:158:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::allocator<_Tp>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/char_traits.h:40:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/string:40,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bitset:47,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:39,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/postypes.h:221:5: note: candidate: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::fpos<_StateT>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1136:5: note: candidate: template<class _Iterator> constexpr bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::move_iterator<_IteratorL>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1130:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr bool std::operator!=(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:1130:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::move_iterator<_IteratorL>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:349:5: note: candidate: template<class _IteratorL, class _IteratorR> constexpr bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:349:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::reverse_iterator<_Iterator>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_algobase.h:67:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:61,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:311:5: note: candidate: template<class _Iterator> constexpr bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_iterator.h:311:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::reverse_iterator<_Iterator>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/utility:70:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:456:5: note: candidate: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:456:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::pair<_T1, _T2>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1946:5: note: candidate: template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator!=(const std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter, _Alloc>&)
     operator!=(const match_results<_Bi_iter, _Alloc>& __m1,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1946:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::match_results<_BiIter, _Alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1419:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)
     operator!=(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1419:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1339:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator!=(const typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)
     operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1339:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1262:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)
     operator!=(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1262:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1188:5: note: candidate: template<class _Bi_iter> bool std::__cxx11::operator!=(const typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)
     operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1188:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1111:5: note: candidate: template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&)
     operator!=(const sub_match<_Bi_iter>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1111:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1031:5: note: candidate: template<class _Bi_iter, class _Ch_traits, class _Ch_alloc> bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)
     operator!=(const __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:1031:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:62:0,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:953:5: note: candidate: template<class _BiIter> bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)
     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)
     ^~~~~~~~
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/regex.h:953:5: note:   template argument deduction/substitution failed:
21 : <source>:21:46: note:   'std::__cxx11::basic_regex<char>' is not derived from 'const std::__cxx11::sub_match<_BiIter>'
    std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;
                            ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
Compiler exited with result code 1
```

#### Clang diagnostic

```
20 : <source>:20:79: error: invalid operands to binary expression ('std::__1::basic_regex<char, std::__1::regex_traits<char> >' and 'std::__1::basic_regex<char, std::__1::regex_traits<char> >')
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
                                                            ~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~
24 : <source>:24:44: note: in instantiation of variable template specialization 'EqualityComparable<std::__1::basic_regex<char, std::__1::regex_traits<char> > >' requested here
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;
                                           ^
28 : <source>:28:20: note: in instantiation of variable template specialization 'Regular<std::__1::basic_regex<char, std::__1::regex_traits<char> > >' requested here
  std::enable_if_t<Regular<std::regex>, std::regex> foo{};
                   ^
24 : <source>:24:44: error: constexpr variable 'Regular<std::__1::basic_regex<char, std::__1::regex_traits<char> > >' must be initialized by a constant expression
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;
                         ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~
28 : <source>:28:20: note: in instantiation of variable template specialization 'Regular<std::__1::basic_regex<char, std::__1::regex_traits<char> > >' requested here
  std::enable_if_t<Regular<std::regex>, std::regex> foo{};
                   ^
28 : <source>:28:20: error: non-type template argument is not a constant expression
  std::enable_if_t<Regular<std::regex>, std::regex> foo{};
                   ^~~~~~~~~~~~~~~~~~~
28 : <source>:28:20: note: initializer of 'Regular<std::__1::basic_regex<char, std::__1::regex_traits<char> > >' is not a constant expression
24 : <source>:24:16: note: declared here
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;
               ^
3 errors generated.
Compiler exited with result code 1
```

#### MSVC diagnostic

```
example.cpp
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
20 : <source>(20): error C2678: binary '==': no operator found which takes a left-hand operand of type 'std::regex' (or there is no acceptable conversion)
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(336): note: could be 'bool std::operator ==(const std::exception_ptr &,const std::exception_ptr &) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(341): note: or       'bool std::operator ==(std::nullptr_t,const std::exception_ptr &) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(346): note: or       'bool std::operator ==(const std::exception_ptr &,std::nullptr_t) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(362): note: or       'bool std::operator ==(const std::error_code &,const std::error_code &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(370): note: or       'bool std::operator ==(const std::error_code &,const std::error_condition &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(378): note: or       'bool std::operator ==(const std::error_condition &,const std::error_code &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(386): note: or       'bool std::operator ==(const std::error_condition &,const std::error_condition &) noexcept' [found using argument-dependent lookup]
20 : <source>(20): note: while trying to match the argument list '(std::regex, std::regex)'
24 : <source>(24): note: see reference to variable template 'const bool EqualityComparable<std::basic_regex<char,std::regex_traits<char> > >' being compiled
28 : <source>(28): note: see reference to variable template 'const bool Regular<std::basic_regex<char,std::regex_traits<char> > >' being compiled
20 : <source>(20): error C2065: 'is_same_v': undeclared identifier
21 : <source>(21): error C2678: binary '!=': no operator found which takes a left-hand operand of type 'std::regex' (or there is no acceptable conversion)
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(351): note: could be 'bool std::operator !=(const std::exception_ptr &,const std::exception_ptr &) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(356): note: or       'bool std::operator !=(std::nullptr_t,const std::exception_ptr &) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(361): note: or       'bool std::operator !=(const std::exception_ptr &,std::nullptr_t) throw()' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(395): note: or       'bool std::operator !=(const std::error_code &,const std::error_code &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(402): note: or       'bool std::operator !=(const std::error_code &,const std::error_condition &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(409): note: or       'bool std::operator !=(const std::error_condition &,const std::error_code &) noexcept' [found using argument-dependent lookup]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(416): note: or       'bool std::operator !=(const std::error_condition &,const std::error_condition &) noexcept' [found using argument-dependent lookup]
21 : <source>(21): note: while trying to match the argument list '(std::regex, std::regex)'
21 : <source>(21): error C2065: 'is_same_v': undeclared identifier
20 : <source>(20): error C2131: expression did not evaluate to a constant
20 : <source>(20): note: failure was caused by non-constant arguments or reference to a non-constant symbol
20 : <source>(20): note: see usage of 'is_same_v'
28 : <source>(28): error C2970: 'std::enable_if_t': template parameter '_Test': 'Regular<std::regex>': an expression involving objects with internal linkage cannot be used as a non-type argument
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): note: see declaration of 'std::enable_if_t'
24 : <source>(24): note: see declaration of 'Regular<std::regex>'
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2039: 'type': is not a member of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=std::regex
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): note: see declaration of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=std::regex
        ]
28 : <source>(28): note: see reference to alias template instantiation 'enable_if_t<false,std::regex>' being compiled
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2061: syntax error: identifier 'type'
28 : <source>(28): error C2938: 'enable_if_t<false,std::regex>' : Failed to specialize alias template
Microsoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
Compiler exited with result code 2
```

### Listing 6

#### Source

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

int main()
{
  Regular foo = std::regex{};
}
```

#### GCC diagnostic

```
<source>: In function 'int main()':
10 : <source>:10:28: error: deduced initializer does not satisfy placeholder constraints
   Regular foo = std::regex{};
                            ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:25:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Regular<T> [with T = std::__cxx11::basic_regex<char>]'
  concept bool Regular =
               ^~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:17:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:94:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::EqualityComparable<T> [with T = std::__cxx11::basic_regex<char>]'
  concept bool EqualityComparable =
               ^~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::WeaklyEqualityComparable<T, U> [with T = std::__cxx11::basic_regex<char>; U = std::__cxx11::basic_regex<char>]'
  concept bool WeaklyEqualityComparable =
               ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note:     with 'std::remove_reference_t<std::__cxx11::basic_regex<char> >& t'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note:     with 'std::remove_reference_t<std::__cxx11::basic_regex<char> >& u'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note: the required expression '(t == u)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note: the required expression '(t != u)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note: the required expression '(u == t)' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:74:15: note: the required expression '(u != t)' would be ill-formed
Compiler exited with result code 1
```

### Listing 7

#### Source

```cpp
#include <regex>
#include <type_traits>

class Foo {
public:
  Foo() = delete; 
};

constexpr bool operator==(const Foo, const Foo) noexcept;
constexpr bool operator!=(const Foo, const Foo) noexcept;

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
}
```

#### GCC diagnostic

```
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/move.h:54:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:59,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/utility:70,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/type_traits: In substitution of 'template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = Foo]':
36 : <source>:36:37:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/type_traits:2479:61: error: no type named 'type' in 'struct std::enable_if<false, Foo>'
     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                                             ^
<source>: In function 'int main()':
36 : <source>:36:49: error: cannot convert 'Foo' to 'int' in initialization
   std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
                                                 ^
Compiler exited with result code 1
```

#### Clang diagnostic

```
In file included from <source>:1:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/regex:758:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/stdexcept:46:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/exception:81:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/cstddef:87:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/type_traits:427:78: error: no type named 'type' in 'std::__1::enable_if<false, Foo>'; 'enable_if' cannot be used to disable this declaration
template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
                                                                             ^~~
36 : <source>:36:8: note: in instantiation of template type alias 'enable_if_t' requested here
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
       ^
1 error generated.
Compiler exited with result code 1
```

#### MSVC diagnostic

```
example.cpp
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2039: 'type': is not a member of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=Foo
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): note: see declaration of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=Foo
        ]
36 : <source>(36): note: see reference to alias template instantiation 'enable_if_t<false,Foo>' being compiled
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2061: syntax error: identifier 'type'
36 : <source>(36): error C2938: 'enable_if_t<false,Foo>' : Failed to specialize alias template
Microsoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
Compiler exited with result code 2
```

### Listing 8

#### Source

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

class Foo {
public:
  Foo() = delete; 
};

constexpr bool operator==(const Foo, const Foo) noexcept;
constexpr bool operator!=(const Foo, const Foo) noexcept;

int main()
{
  Regular foo = Foo{};
}
```

#### GCC diagnostic

```
<source>: In function 'int main()':
18 : <source>:18:21: error: deduced initializer does not satisfy placeholder constraints
   Regular foo = Foo{};
                     ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:25:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Regular<T> [with T = Foo]'
  concept bool Regular =
               ^~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:18:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/semiregular.hpp:66:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Semiregular<T> [with T = Foo]'
  concept bool Semiregular =
               ^~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:97:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::DefaultConstructible<T> [with T = Foo]'
  concept bool DefaultConstructible =
               ^~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
<source>: At global scope:
13 : <source>:13:16: warning: inline function 'constexpr bool operator==(Foo, Foo)' used but never defined
 constexpr bool operator==(const Foo, const Foo) noexcept;
                ^~~~~~~~
14 : <source>:14:16: warning: inline function 'constexpr bool operator!=(Foo, Foo)' used but never defined
 constexpr bool operator!=(const Foo, const Foo) noexcept;
                ^~~~~~~~
Compiler exited with result code 1
```

### Listing 9

#### Source

```cpp
#include <regex>
#include <type_traits>

class Foo {
public:
  Foo() = delete;
  Foo(const Foo&) = delete;
};

constexpr bool operator==(const Foo&, const Foo&) noexcept;
constexpr bool operator!=(const Foo&, const Foo&) noexcept;

template <typename T>
constexpr bool Destructible = std::is_destructible_v<T>;

template <typename T>
constexpr bool DefaultConstructible = Destructible<T> && std::is_default_constructible_v<T>;

template <typename T>
constexpr bool Movable = Destructible<T> && std::is_move_constructible_v<T> && std::is_move_assignable_v<T>;

template <typename T>
constexpr bool Copyable = Destructible<T> && std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>;

template <typename T>
constexpr bool Semiregular = Copyable<T> && DefaultConstructible<T>;

template <typename T>
constexpr bool EqualityComparable = std::is_same_v<decltype(std::declval<T>() == std::declval<T>()), bool> &&
   std::is_same_v<decltype(std::declval<T>() != std::declval<T>()), bool>;

template <typename T>
constexpr bool Regular = Semiregular<T> && EqualityComparable<T>;

int main()
{
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
}
```

#### GCC diagnostic

```
In file included from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/move.h:54:0,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/bits/stl_pair.h:59,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/utility:70,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/algorithm:60,
                 from /opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/regex:38,
                 from <source>:1:
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/type_traits: In substitution of 'template<bool _Cond, class _Tp> using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = Foo]':
37 : <source>:37:37:   required from here
/opt/compiler-explorer/gcc-7.2.0/include/c++/7.2.0/type_traits:2479:61: error: no type named 'type' in 'struct std::enable_if<false, Foo>'
     using enable_if_t = typename enable_if<_Cond, _Tp>::type;
                                                             ^
<source>: In function 'int main()':
37 : <source>:37:49: error: cannot convert 'Foo' to 'int' in initialization
   std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
                                                 ^
Compiler exited with result code 1
```

#### Clang diagnostic

```
In file included from <source>:1:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/regex:758:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/stdexcept:46:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/exception:81:
In file included from /opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/cstddef:87:
/opt/compiler-explorer/clang-5.0.0/bin/../include/c++/v1/type_traits:427:78: error: no type named 'type' in 'std::__1::enable_if<false, Foo>'; 'enable_if' cannot be used to disable this declaration
template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
                                                                             ^~~
37 : <source>:37:8: note: in instantiation of template type alias 'enable_if_t' requested here
  std::enable_if_t<Regular<Foo>, Foo> foo = Foo{};
       ^
1 error generated.
Compiler exited with result code 1
```

#### MSVC diagnostic

```
example.cpp
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2039: 'type': is not a member of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=Foo
        ]
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): note: see declaration of 'std::enable_if<false,_Ty>'
        with
        [
            _Ty=Foo
        ]
37 : <source>(37): note: see reference to alias template instantiation 'enable_if_t<false,Foo>' being compiled
/opt/compiler-explorer/windows/19.10.25017/lib/native/include/type_traits(2099): error C2061: syntax error: identifier 'type'
37 : <source>(37): error C2938: 'enable_if_t<false,Foo>' : Failed to specialize alias template
Microsoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
err:msvcrt:demangle_datatype Unknown type s
Compiler exited with result code 2
```

### Listing 10

#### Source

```cpp
#include <experimental/ranges/algorithm>
#include <experimental/ranges/iterator>
#include <regex>

namespace ranges = std::experimental::ranges;
using ranges::Regular;

class Foo {
public:
  Foo() = delete;
  Foo(const Foo&) = delete;
};

constexpr bool operator==(const Foo&, const Foo&) noexcept;
constexpr bool operator!=(const Foo&, const Foo&) noexcept;

int main()
{
  Regular foo = Foo{};
}
```

#### GCC diagnostic

```
<source>: In function 'int main()':
19 : <source>:19:21: error: deduced initializer does not satisfy placeholder constraints
   Regular foo = Foo{};
                     ^
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:25:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Regular<T> [with T = Foo]'
  concept bool Regular =
               ^~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:18:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/semiregular.hpp:66:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Semiregular<T> [with T = Foo]'
  concept bool Semiregular =
               ^~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/semiregular.hpp:50:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Copyable<T> [with T = Foo]'
  concept bool Copyable =
               ^~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/semiregular.hpp:30:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::CopyConstructible<T> [with T = Foo]'
  concept bool CopyConstructible =
               ^~~~~~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:112:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::MoveConstructible<T> [with T = Foo]'
  concept bool MoveConstructible =
               ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {Foo}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::ConvertibleTo<T, U> [with T = Foo; U = Foo]'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_convertible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {Foo&}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {Foo&}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {const Foo&}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {const Foo&}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {const Foo&&}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {const Foo&&}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::ConvertibleTo<T, U> [with T = Foo&; U = Foo]'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo&; T = std::is_convertible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note:     with 'Foo& (& t)()'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: the required expression 'static_cast<U>(t())' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::ConvertibleTo<T, U> [with T = const Foo&; U = Foo]'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = const Foo&; T = std::is_convertible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note:     with 'const Foo& (& t)()'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: the required expression 'static_cast<U>(t())' would be ill-formed
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::ConvertibleTo<T, U> [with T = const Foo&&; U = Foo]'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = const Foo&&; T = std::is_convertible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note:     with 'const Foo&& (& t)()'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: the required expression 'static_cast<U>(t())' would be ill-formed
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/compare.hpp:20:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/regular.hpp:17,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object.hpp:20,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:22,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/movable.hpp:28:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Movable<T> [with T = Foo]'
  concept bool Movable =
               ^~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:112:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::MoveConstructible<T> [with T = Foo]'
  concept bool MoveConstructible =
               ^~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {Foo}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:98:15: note: within 'template<class T, class U> concept const bool std::experimental::ranges::v1::ConvertibleTo<T, U> [with T = Foo; U = Foo]'
  concept bool ConvertibleTo =
               ^~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_convertible; V = {Foo}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:108:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::Swappable<T> [with T = Foo]'
  concept bool Swappable =
               ^~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:108:15: note:     with 'Foo& a'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:108:15: note:     with 'Foo& b'
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:108:15: note: the required expression 'std::experimental::ranges::v1::{anonymous}::swap(a, b)' would be ill-formed
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:21:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:97:15: note: within 'template<class T> concept const bool std::experimental::ranges::v1::DefaultConstructible<T> [with T = Foo]'
  concept bool DefaultConstructible =
               ^~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/object/move_constructible.hpp:82:15: note: within 'template<class T, class ... Args> concept const bool std::experimental::ranges::v1::Constructible<T, Args ...> [with T = Foo; Args = {}]'
  concept bool Constructible =
               ^~~~~~~~~~~~~
In file included from /opt/compiler-explorer/libs/cmcstl2/include/stl2/type_traits.hpp:19:0,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/swap.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/tagged.hpp:19,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/algorithm/tagspec.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/stl2/algorithm.hpp:16,
                 from /opt/compiler-explorer/libs/cmcstl2/include/experimental/ranges/algorithm:12,
                 from <source>:1:
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: within 'template<class U, template<class ...> class T, class ... V> concept const bool std::experimental::ranges::v1::_Is<U, T, V ...> [with U = Foo; T = std::is_constructible; V = {}]'
  concept bool _Is = _Valid<T, U, V...> && __bool<T<U, V...>::value>;
               ^~~
/opt/compiler-explorer/libs/cmcstl2/include/stl2/detail/concepts/core.hpp:30:15: note: 'std::experimental::ranges::v1::__bool' evaluated to false
compilation terminated due to -fmax-errors=1.
Compiler exited with result code 1
```
