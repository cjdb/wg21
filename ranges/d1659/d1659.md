# D1659R0 `starts_with` and `ends_with`

* Author: [Christopher Di Bella][cjdb]
* Audience: LEWG(I)

## Abstract

This proposal seeks to add a `std::ranges::starts_with` and a `std::ranges::ends_with`, which would
work on arbitrary ranges, and also answer questions such as "are the starting elements of `r1`
_less than_ the elements of `r2`?" and "are the final elements of `r1` _greater than_ the elements
of `r2`?"

## Motivation

C++20 is introducing `basic_string::starts_with`, `basic_string::ends_with`,
`basic_string_view::starts_with`, and `basic_string_view::ends_with`. Both `basic_string` and
`basic_string_view` are already monolithic types in C++17, with many member functions that duplicate
algorithm functionality (e.g. `basic_string::copy`, `basic_string::find`, `basic_string::rfind`,
etc.). It is the author's opinion that `basic_string` and `basic_string_view` should _not_ have
`starts_with` and `ends_with` added as member functions; rather they should be algorithms that have
the potential to work on non-strings, as well as the potential to use different comparison
operations.

### Example usage

```cpp
auto script = u8"OBI-WAN: Hello, there!\n"
              u8"GENERAL GRIEVOUS: General Kenobi, you are a bold one."sv;
namespace ranges = std::ranges;
ranges::starts_with(script, u8"OBI-WAN"sv);               // returns true
ranges::starts_with(script, u8"ABCDEFG"sv);               // returns false
ranges::starts_with(script, u8"ABCDEFG"sv, ranges::less); // returns true

namespace view = ranges::view;
ranges::ends_with(view::iota(0, 50), view::iota(30) | view::take(20));       // returns true
ranges::ends_with(view::iota(0, 50), view::iota(30) | view::take(50));       // returns false
ranges::ends_with(view::iota(0, 50), view::iota(-50, -40), ranges::greater); // returns true
```

### C++20 or C++23?

Given that C++20 is now feature-locked and that is decidedly a dramatic on-the-fly change, P1659 is
targeting C++23. In response to the concerns outlined in the motivation section of this document,
the author would like to request that LEWG consider discussing adopting in SD-8, a policy of
ensuring that options for algorithms are explored when a proposal to add a member function to a
container-like type is considered.

## Proposed changes

Add the following text to [algorithm.synopsis]:

```diff
...
template<class ForwardIterator, class Searcher>
  constexpr ForwardIterator
    search(ForwardIterator first, ForwardIterator last, const Searcher& searcher);

+ namespace ranges {
+   // [alg.starts_with], starts_with
+   template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
+            class Comp = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+     requires IndirectlyComparable<I1, I2, Comp, Proj1, Proj2>
+   constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
+                              Proj1 proj1 = {}, Proj2 proj2 = {});
+   template<InputRange R1, InputRange R2, class Comp = ranges::equal_to, class Proj1 = identity,
+            class Proj2 = identity>
+     requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2>
+   constexpr bool starts_with(R1&& r1, R2&& r2, Comp comp = {}, Proj1 proj1 = {},
+                              Proj2 proj2 = {});
+
+   // [alg.ends_with], ends_with
+   template<ForwardIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
+            class Comp = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
+     requires IndirectlyComparable<I1, I2, Comp, Proj1, Proj2>
+   constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
+                            Proj1 proj1 = {}, Proj2 proj2 = {});
+   template<ForwardRange R1, InputRange R2, class Comp = ranges::equal_to, class Proj1 = identity,
+            class Proj2 = identity>
+     requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2>
+   constexpr bool ends_with(R1&& r1, R2&& r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
+ }

// [alg.modifying.operations], mutating sequence operations
// [alg.copy], copy
...
```

Add the following two sections to [alg.nonmodifying]:

### 25.5.14 Starts with [alg.starts_with]

```cpp
namespace ranges {
  template<InputIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
           class Comp = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Comp, Proj1, Proj2>
  constexpr bool starts_with(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                             Proj1 proj1 = {}, Proj2 proj2 = {});
  template<InputRange R1, InputRange R2, class Comp = ranges::equal_to, class Proj1 = identity,
           class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2>
  constexpr bool starts_with(R1&& r1, R2&& r2, Comp comp = {}, Proj1 proj1 = {},
                             Proj2 proj2 = {});
}
```

1. _Equivalent to_:
```cpp
return ranges::mismatch(first1, last1, first2, last2, comp, proj1, proj2).in2 == last2;
```

2. _Complexity_: If the types of `first1`, `last1`, `first2`, and `last2` pairwise model
   `SizedSentinel` and `last1 - first1 != last2 - first2`, then no applications of the corresponding
   predicate and each projection; otherwise, at most min(`last1 - first1`, `last2 - first2)`)
   applications of the corresponding predicate and projections.

### 25.5.15 Ends with [alg.ends_with]

```cpp
  template<ForwardIterator I1, Sentinel<I1> S1, InputIterator I2, Sentinel<I2> S2,
           class Comp = ranges::equal_to, class Proj1 = identity, class Proj2 = identity>
    requires IndirectlyComparable<I1, I2, Comp, Proj1, Proj2>
  constexpr bool ends_with(I1 first1, S1 last1, I2 first2, S2 last2, Comp comp = {},
                           Proj1 proj1 = {}, Proj2 proj2 = {});
  template<ForwardRange R1, InputRange R2, class Comp = ranges::equal_to, class Proj1 = identity,
           class Proj2 = identity>
    requires IndirectlyComparable<iterator_t<R1>, iterator_t<R2>, Comp, Proj1, Proj2>
  constexpr bool ends_with(R1&& r1, R2&& r2, Comp comp = {}, Proj1 proj1 = {}, Proj2 proj2 = {});
```

1. _Equivalent to_:
```cpp
const auto first = subrange{first1, last1};
const auto second = subrange{first2, last2};
return ranges::equal(first | view::drop(ranges::distance(second)), second, comp, proj1, proj2);
```

2. _Complexity_: If the types of `first1`, `last1`, `first2`, and `last2` pairwise model
   `SizedSentinel` and `last1 - first1 != last2 - first2`, then no applications of the corresponding
   predicate and each projection; otherwise, at most min(`last1 - first1`, `last2 - first2`)
   applications of the corresponding predicate and projections.

## Reference implementation

Both [`starts_with`][starts_with] and [`ends_with`][ends_with] have been implemented in range-v3.

## Acknowledgements

The author would like to thank Johel Ernesto Guerrero Pe√±a for providing an implementation for
`ends_with`, and Eric Niebler for merging the respectivepull requests to range-v3.


[cjdb]: cjdb.ns@gmail.com
[starts_with]: https://git.io/fjzqR
[ends_with]: https://git.io/fjzq0
