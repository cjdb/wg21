<pre class='metadata'>
Title: Input range adaptors
Shortname: D1035
Level: 2
Status: D
Group: wg21
Editor: Christopher Di Bella, cjdb.ns@gmail.com
Editor: Casey Carter, casey@carter.com
Editor: Corentin Jabot, corentin.jabot@gmail.com
URL: https://wg21.link/p1035
Abstract: P1035 proposes to introduce seven additional range adaptors in the C++20 timeframe.
Audience: LEWG
Markup Shorthands: markdown yes
Default Highlight: CPP
Line Numbers: no
Date: 2018-10-08
</pre>

# Changes

## From R1 to R2

* Expanded acknowledgements and co-authors.
* Removed `zip_with_view`.
* Added `zip_view`.
* Added `keys` and `values`.
* Added content for associated types for ranges.
* Added `repeat_view` to compensate for the absence of `zip_with_view`.

## From R0 to R1

* Revised `istream_range`.
	* Renamed to `basic_istream_view`.
	* Introduced some relevant concepts.
* Introduced `drop_view`, `take_while_view`, `drop_while_view`.
* Teased `zip_with_view`.
* Teased associated types for ranges.

# Acknowledgements

We would like to acknowledge the following people for their assistance with this proposal:

* Eric Niebler, for providing [[range-v3]] as a reference implementation.
* Tim Song for their reviews of P1035.


# Motivation

[[P0789]] introduces the notion of a range adaptor and twelve pioneering range adaptors that
improve declarative, range-based programming. For example, it is possible to perform an inline,
in-place, lazy reverse like so:

```cpp
namespace ranges = std::ranges;
namespace view = std::ranges::view;

// Old
auto i = ranges::find(ranges::rbegin(employees), ranges::rend(employees), "Lovelace", &employee::surname);

// New
auto j = ranges::find(employees | view::reverse, "Lovelace", &employee::surname);
[[assert: i == j]];
```

P1035 recognises that P0789 introduces only a few of the widely experimented-with range adaptors in
[[range-v3]], and would like to add a few more to complete the C++20 phase of range adaptors. To
this end, P1035 discusses range adaptors that are related to those in P0789.

# Proposals

Unless otherwise requested, each sub-subsection below should be polled individually from other
sub-subsections. Two major questions are to be asked per range adaptor. It is up to LEWG to decide
the exact phrasing, but the author's intentions are listed below.

1. Do we want this range adaptor in C++20?
   1. As-is?
   2. With modifications, as suggested by LEWG?
2. If we do not want this range adaptor in C++20, do we want it in C++23?
   1. As-is?
   2. With modificaitons, as suggested by LEWG?

## `take_while_view`

### Motivation

P0789 introduces `take_view`, which rangifies the iterator pair
`{ranges::begin(r), ranges::next(ranges::begin(r), n, ranges::end(r))}`. As an example:

```cpp
auto v = std::vector{0, 1, 2, 3, 4, 5};
std::cout << distance(v | view::take(3)) << '\n'; // prints 3
copy(v | view::take(3), ostream_iterator<int>(std::cout, " ")); // prints 0 1 2
copy(v | view::take(distance(v)), ostream_iterator<int>(std::cout, " ")); // prints 0 1 2 3 4 5
```

`take_while_view` will provide slightly different functionality, akin to having a sentinel that
checks if a certain predicate is satisfied.

<table>
   <tr>
      <th>Current</th>
      <th>Proposed</th>
   </tr>
   <tr>
   <td>
   <xmp>
    namespace ranges = std::experimental::ranges;

    template <ranges::Integral I>
    constexpr bool is_odd(I const i) noexcept
    {
       return i % 2;
    }

    struct is_odd_sentinel {
       template <ranges::Iterator I>
       constexpr friend bool operator==(I const& a,
          is_odd_sentinel) noexcept
       {
          return is_odd(*a);
       }

       template <ranges::Iterator I>
       constexpr friend bool operator==(is_odd_sentinel const a,
          I const& b) noexcept
       {
          return b == a;
       }

       template <ranges::Iterator I>
       constexpr friend bool operator!=(I const& a,
          is_odd_sentinel const b) noexcept
       {
          return not (a == b);
       }

       template <ranges::Iterator I>
       constexpr friend bool operator!=(is_odd_sentinel const a,
          I const& b) noexcept
       {
          return not (b == a);
       }
    };

    int main()
    {
       auto v = std::vector{0, 6, 8, 9, 10, 16};
       ranges::copy(
         ranges::begin(v),
         is_odd_sentinel{},
         ranges::ostream_iterator<int>(std::cout, "\n"));
    }
   </xmp>
   </td>
   <td>
   <xmp>
    namespace ranges = std::experimental::ranges;

    template <ranges::Integral I>
    constexpr bool is_odd(I const i) noexcept
    {
       return i % 2;
    }

    template <ranges::Integral I>
    constexpr bool is_even(I const i) noexcept
    {
       return not is_odd(i);
    }

    int main()
    {
       namespace view = ranges::view;
       auto v = std::vector{0, 6, 8, 9, 10, 16};
       ranges::copy(
          v | view::take_while(is_even<int>),
          ranges::ostream_iterator<int>(std::cout, "\n"));
    }
   </xmp>
   </td>
   </tr>
   <tr>
      <td><a href="https://wandbox.org/permlink/7UXazMHnbxfOfODQ">Wandbox demo</a></td>
      <td><a href="https://wandbox.org/permlink/2nS3bzVuQX1DR0yJ">Wandbox demo</a></td>
   </tr>
</table>

The former requires that a user define their own sentinel type: something that while not
expert-friendly, is yet to be established as a widespread idiom in C++, and providing a
range adaptor for this purpose will help programmers determine when a sentinel is _not_
necessary.

### Notes
* There is a slight programmer overhead in the naming: the author felt that both
    `is_odd_sentinel` and `is_even_sentinel` were applicable names: ultimately, the name
    `is_odd_sentinel` was chosen because it describes the delimiting condition. An equally
    valid reason could probably be made for `is_even_sentinel`.
* A sentinel that takes a lambda may be of interest to LEWG. If there is interest in
    this, a proposal could be made in the C++23 timeframe.

### Interface and specification

```cpp
template <View R, class Pred>
requires
   InputRange<R> &&
   std::is_object_v<Pred> &&
   IndirectUnaryPredicate<const Pred, iterator_t<R>
class take_while_view : public view_interface<take_while_view<R, Pred>> {
   template<bool> class __sentinel; // exposition-only
public:
   take_while_view() = default;
   constexpr take_while_view(R base, Pred pred);

   template <ViewableRange O>
   requires constructible-from-range<R, O>
   constexpr take_while_view(O&& o, Pred pred);

   constexpr R base() const;
   constexpr const Pred& pred() const;

   constexpr auto begin() requires !SimpleView<R>;
   constexpr auto begin() const requires Range<const R>;

   constexpr auto end() requires !SimpleView<R>;
   constexpr auto end() const requires Range<const R>;
private:
   R base_; // exposition-only
   semiregular<Pred> pred_; // exposition-only
};

template<class R, class Pred>
take_while_view(R&&, Pred) -> take_while_view<all_view<R>, Pred>;
```

#### `take_while_view` constructors

```cpp
constexpr take_while_view(R base, Pred pred);
```

1. <i>Effects</i>: Initialises `base_` with `base` and initialises `pred_` with `pred`.

```cpp
template <ViewableRange O>
requires constructible-from-range<R, O>
constexpr take_while_view(O&& o, Pred pred);
```

2. <i>Effects</i>: Initialises `base_` with `view::all(std::forward<O>(o))` and initialises
    `pred_` with `pred`.

#### `take_while_view` conversion

```cpp
constexpr R base() const;
```

1. <i>Returns</i>: `base_`.

```cpp
constexpr const Pred& pred() const;
```

2. <i>Returns</i>: `pred_`.

#### `take_while_view` range begin

```cpp
constexpr auto begin() requires !SimpleView<R>;
constexpr auto begin() const requries Range<const R>
```

1. <i>Effects</i>: Equivalent to `return ranges::begin(base_);`.

#### `take_while_view` range end

```cpp
constexpr auto end() requires !SimpleView<R>;
constexpr auto end() const requires Range<const R>;
```

1. <i>Effects</i>: Equivalent to `return __sentinel<is_const_v<decltype(*this)>>(&pred());`.

### `take_while_view::__sentinel`

```cpp
template<class R, class Pred>
template<bool Const>
class take_while_view<R, Pred>::__sentinel {
   using Parent = conditional_t<Const, const take_while_view, take_wile_view>;
   using Base = conditional_t<Const, const R, R>;
   sentinel_t<Base> end_{}; // exposition-only
   const Pred* pred_{}; // pred
public:
   __sentinel() = default;
   constexpr explicit __sentinel(sentinel_t<Base> end, const Pred* pred);
   constexpr __sentinel(__sentinel<!Const> s)
     requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>

   constexpr sentinel_t<Base> base() const { return end_; }

   friend constexpr bool operator==(const __sentinel& x, const iterator_t<Base>& y);
   friend constexpr bool operator==(const iterator_t<Base>& x, const __sentinel& y);
   friend constexpr bool operator!=(const __sentinel& x, const iterator_t<Base>& y);
   friend constexpr bool operator!=(const iterator_t<Base>& x, const __sentinel& y);
};
```

### `take_while_view::__sentinel` constructor

```cpp
constexpr explicit __sentinel(sentinel_t<Base> end, const Pred* pred);
```

1. <i>Effects</i>: Initialises `end_` with `end`, and `pred_` with `pred`.

```cpp
constexpr __sentinel(__sentinel<!Const> s)
   requires Const && ConvertibleTo<sentinel_t<R>, sentinel_t<Base>>;
```

2. <i>Effects</i> Initialises `end_` with `s.end_` and `pred_` with `s.pred_`.

### `take_while_view::__sentinel` conversion

```cpp
constexpr sentinel_t<Base> base() const;
```

3. <i>Effects</i>: Equivalent to `return end_;`

### `take_while_view::__sentinel` comparisons

```cpp
friend constexpr bool operator==(const __sentinel& x, const iterator_t<Base>& y)
```

4. <i>Effects</i>: Equivalent to `return x.end_ != y && !(*x.pred_)(*y);`.

```cpp
friend constexpr bool operator==(const iterator_t<Base>& x, const __sentinel& y);
```

5. <i>Effects</i>: Equivalent to `return y == x;`.

```cpp
friend constexpr bool operator!=(const __sentinel& x, const iterator_t<Base>& y);
```

6. <i>Effects</i>: Equivalent to `!(x == y);`.

```cpp
friend constexpr bool operator!=(const iterator_t<Base>& x, const __sentinel& y);
```

7. <i>Effects</i>: Equivalent to `!(y == x);`.

## `view::take_while`

The name `view::take_while` denotes a range adaptor object. Let `E` and `F`
be expressions such that type `T` is `decltype((E))`. Then, the expression 
`view::take_while(E, F)`is expression-equivalent to:

1. `take_while_view{E, F}` if `T` models `InputRange` and if `F` is an object, and
    models `IndirectUnaryPredicate`.
2. Otherwise `std::ranges::view::take_while(E, F)` is ill-formed.

## `drop_view`

### Motivation

`drop_view` is the complement to `take_view`: instead of providing the user with the
first _n_ elements, it provides the user with all _but_ the first _n_ elements.

<table>
   <tr>
      <th>Current (C++17)</th>
      <th>Proposed (C++20)</th>
   </tr>
   <tr>
      <td><xmp>
    namespace ranges = std::ranges;
    auto i = ranges::next(ranges::begin(employees), 5, ranges::end(employees));
    auto j = ranges::find(i, ranges::end(employees), "Lovelace", &employees::surname);
      </xmp></td>
      <td><xmp>
    namespace view = ranges::view;
    auto j = ranges::find(employees | view::drop(5), "Lovelace", &employees::surname);
      </xmp></td>
   </tr>
</table>

### Interface

```cpp
template<View R>
class drop_view : public view_interface<drop_view<R>> {
   using D = iter_distance_t<iterator_t<R>>; // exposition-only
public:
   drop_view();
   constexpr drop_view(R base, D count);

   template<ViewableRange O>
   requires constructible-from-range<R, O>
   constexpr drop_view(O&& o, D count);

   constexpr R base() const;

   constexpr auto begin() requires !(SimpleView<R> && RandomAccessRange<R>);
   constexpr auto begin() const requires Range<const R> && RandomAccessRange<const R>;
   constexpr auto end() requires !(SimpleView<R>);
   constexpr auto end() const requires Range<const R>;

   constexpr auto size() requires !SimpleView<R> && SizedRange<R>;
   constexpr auto size() const requires SizedRange<const R>;
private:
   R base_; // exposition-only
   D count_; // exposition-only
};

template<Range R>
drop_view(R&&, iter_difference_t<iterator_t<R>>) -> drop_view<all_view<R>>;
```

#### `drop_view` constructor

```cpp
constexpr drop_view(R base, D count);
```

1. <i>Effects</i>: Initialises `base_` with `base` and `count_` with `count`.

```cpp
template<ViewableRange O>
requires constructible-from-range<R, O>
constexpr drop_view(O&& o, D count);
```

2. <i>Effects</i>: Initialises `base_` with `view::all(std::forward<O>(o))` and `count_` with
    `count`.

#### `drop_view` conversion

```cpp
constexpr R base() const;
```

3. <i>Effects</i>: Equivalent to `return base_`.

#### `drop_view` range begin

```cpp
constexpr auto begin() requires !(SimpleView<R> && RandomAccessRange<R>);
constexpr auto begin() const requires Range<const R> && RandomAccessRange<const R>;
```

4. <i>Effects</i>: Equivalent to `return ranges::next(ranges::begin(base_), count_, ranges::end(base_));`.
5. _Remarks_: In order to provide the amortized constant time complexity required by the
    Range concept, this function caches the result within the `drop_view` for use on
    subsequent calls.

#### `drop_view` range end

```cpp
constexpr auto end() requires !(SimpleView<R>);
constexpr auto end() const requires Range<const R>;
```

6. <i>Effects</i>: Equivalent to `return ranges::end(base_);`.

#### `drop_view` size

```cpp
constexpr auto size() requires !SimpleView<R> && SizedRange<R>;
constexpr auto size() const requires SizedRange<const R>;
```

7. Equivalent to:

```cpp
auto const size = ranges::size(base_);
auto const count = static_cast<decltype(size)>(count_);
return size < count ? 0 : size - count;
```

## `view::drop`

The name `view::drop` denotes a range adaptor object. Let `E` and `F` be expressions such that type
`T` is `decltype((E))`. Then, the expression  `view::drop(E, F)`is expression-equivalent to:

1. `drop_view{E, F}` if `T` models `InputRange` and `F` is implicitly convertible to
    `iter_difference_t<iterator_t<T>>`.
2. Otherwise `view::drop(E, F)` is ill-formed.

## `drop_while_view`

### Motivation

The motivation for `drop_while_view` is the union of `drop_view` and `take_while_view`.
Unlike the others, there are two demonstrations of `drop_while_view` below.

<table>
  <tr><th>Current (C++17)</th><th>Proposed (C++20) v1</th></tr>
  <tr>
    <td>
      <xmp>
    auto begin = ranges::find_if_not(employees, [](auto const holidays){ return holidays < 20; }, &employee::holidays);
    ranges::transform(begin, ranges::end(employees), ranges::ostream_iterator<std::string>(std::cout, "\n"), [](auto const& e) {
       return e.given_name() + e.surname(); });
      </xmp>
  </td>
      <td>
         <xmp>
    auto too_many_holidays = employees | view::drop_while([](auto const e) { return e.holidays() < 20; });
    ranges::transform(too_many_holidays,
       ranges::ostream_iterator<std::string>(std::cout, "\n"),
       [](auto const& e) { return e.given_name() + e.surname(); });
         </xmp>
      </td>
  </tr>
</table>

### Interface

```cpp
template<View R, class Pred>
requires
  InputRange<R> &&
  std::is_object_v<Pred> &&
  IndirectPredicate<const Pred, iterator_t<R>>
class drop_while_view : public view_interface<drop_while_view<R, Pred>> {
public:
   drop_while_view() = default;

   constexpr drop_while_view(R base, Pred pred);

   template<ViewableRange O>
   requires constructible-from-range<R, O>
   constexpr drop_while_view(O&& o, Pred pred);

   constexpr R base() const;
   constexpr Pred pred() const;

   constexpr auto begin();
   constexpr auto end();
private:
   R base_; // exposition-only
   semiregular<Pred> pred_; // exposition-only
};

template<class R, class Pred>
drop_while_view(R&&, Pred) -> drop_while_view<all_view<R>, Pred>;
```

#### `drop_while_view` constructors

```cpp
constexpr drop_while_view(R base, Pred pred);
```

1. <i>Effects</i>: Initialises `base_` with `base` and initialises `pred_` with `pred`.

```cpp
template<ViewableRange O>
requires constructible-from-range<R, O>
constexpr drop_while_view(O&& o, Pred pred)
```

2. <i>Effects</i>: Initialises `base_` with `view::all(std::forward<O>(o))`, and intialises
    `pred_` with `pred`.

#### `drop_while_view` conversion

```cpp
constexpr R base() const;
```

3. <i>Returns</i>: `base_`.

```cpp
constexpr Pred pred() const;
```

4. <i>Returns</i>: `pred_`.

#### `drop_while_view` begin

```cpp
constexpr auto begin();
```

5. <i>Effects</i>: Equivalent to `return ranges::find_if_not(base_, std::ref(pred_));`.
6. _Remarks_: In order to provide the amortized constant time complexity required by the `Range`
    concept, this function caches the result within the `drop_while_view` for use on subsequent
    calls.

#### `drop_while_view` end

7. <i>Effects</i>: Equivalent to `return ranges::end(base_);`.

## `view::drop_while`

The name `view::drop_while` denotes a range adaptor object. Let `E` and `F` be expressions such that
type `T` is `decltype((E))`. Then, the expression `view::drop_while(E, F)`is expression-equivalent
to:

1. `drop_while_view{E, F}` if `T` models `InputRange`, and `F` is both an object and models
    `IndirectUnaryPredicate`.
2. Otherwise `view::drop(E, F)` is ill-formed.

## `basic_istream_view`

### Motivation

`istream_iterator` is an abstraction over a `basic_istream` object, so that it may be used as though
it were an input iterator. It is a great way to populate a container from the get-go, or fill a
container later in its lifetime. This is great, as copy is a standard algorithm that cleanly
communicates that we're copying something from one range into another. There aren’t any Hidden
Surprises<sup>TM</sup>. This is also good when writing generic code, because the generic library
author does not need to care how things are inserted at the end of `v`, only that they are.

<table>
  <tr><th>Without <code>istream_iterator</code></th><th>With <code>istream_iterator</code></th></tr>
  <tr><td><xmp>
    auto v = []{
       auto result = std::vector<int>{};
       for (auto i = 0; std::cin >> i;) {
          result.push_back(i);
       }
    }();
    // ...
    for (auto i = 0; std::cin >> i;) {
       result.push_back(i);
    }
  </xmp></td>
  <td><xmp>

    auto v = std::vector(istream_iterator<int>{std::cin}, istream_iterator<int>{});
    // ...
    copy(istream_iterator<int>{std::cin}, istream_iterator<int>{}, back_inserter(v));

  </xmp></td>
  </tr>
</table>

The problem with `istream_iterator` is that we need to provide a bogus `istream_iterator<T>{}`
(or `default_sentinel{}`) every time we want to use it; this acts as the sentinel for
`istream_iterator`. It is bogus, because the code is equivalent to saying "from the first element of
the istream range until the last element of the istream range", but an `istream` range does not have
a last element. Instead, we denote the end of an istream range to be when the `istream`'s failbit is
set. This is otherwise known as the _end-of-stream_ iterator value, but it doesn’t denote a
'past-the-last element' in the same way that call to `vector<T>::end` does. Because it is the same
for every range, the _end-of-stream_ object may as well be dropped, so that we can write code that
resembles the code below.

```cpp
auto v = std::vector(ranges::istream_view<int>{std::cin});
// ...
copy(ranges::istream_view<int>{std::cin}, back_inserter(v));
```

This code is cleaner: we are implicitly saying "until our `basic_istream` object fails, insert our
input into the back of `v`". There is less to read (and type!), and the code is simpler for it.

### Interface

```cpp
template<class T, class CharT = char, class Traits = char_traits<CharT>>
concept bool StreamExtractable = see-below;

template<class T, class charT = char, class traits = std::char_traits<charT>>
concept bool StreamInsertable = see-below;

template<Semiregular Val, class CharT, class Traits = char_traits<CharT>>
requires StreamExtractable<Val, CharT, Traits>
class basic_istream_view : public view_interface<basic_istream_view<Val, CharT, Traits>> {
public:
   basic_istream_view() = default;

   explicit constexpr basic_istream_view(std::basic_istream<CharT, Traits>& stream);

   constexpr auto begin();
   constexpr default_sentinel end() const noexcept;
private:
   struct __iterator; // exposition-only
   std::basic_istream<CharT, Traits>* stream_; // exposition-only
   Val object_; // exposition-only
};
```

#### Concept `StreamExtractable`

```cpp
template<class T, class CharT = char, class Traits = char_traits<CharT>>
concept bool StreamExtractable =
   requires(std::basic_istream<charT, traits>& is, T& t) {
      { is >> t } -> Same<std::basic_istream<charT, traits>>&;
   };
```

1. <i>Remarks</i>: `std::addressof(is) == std::addressof(is << t)`.

#### Concept `StreamInsertable`

```cpp
template<class T, class charT = char, class traits = std::char_traits<charT>>
concept bool StreamInsertable =
   requires(std::basic_ostream<charT, traits>& os, const T& t) {
      { os << t } -> Same<std::basic_ostream<charT, traits>>&;
   };
```

2. <i>Remarks</i>: `std::addressof(os) == std::addressof(os >> t)`.

#### `basic_istream_view` constructor

```cpp
explicit constexpr basic_istream_view(std::basic_istream<CharT, Traits>& stream);
```

3. <i>Effects</i>: Initialises `stream_` to `std::addressof(stream)`.

#### `basic_istream_view` begin

```cpp
constexpr auto begin();
```

4. <i>Effects</i>: Equivalent to

```cpp
*stream_ >> object_;
return __iterator{*this};
```

#### `basic_istream_view` end

```cpp
constexpr default_sentinel end() const noexcept;
```

5. <i>Returns</i>: `default_sentinel{}`.

#### `basic_istream_view::__iterator`

```cpp
template<class Val, class CharT, class Traits>
class basic_istream_view<Val, CharT, Traits>::__iterator {
public:
   using iterator_category = input_iterator_tag;
   using difference_type = std::ptrdiff_t;
   using value_type = Val;

   __iterator() = default;

   explicit constexpr __iterator(istream_view<Val>& parent) noexcept;

   __iterator& operator++();
   void operator++(int);

   Val& operator*() const;

   friend bool operator==(__iterator x, default_sentinel);
   friend bool operator==(default_sentinel y, __iterator x);
   friend bool operator!=(__iterator x, default_sentinel y);
   friend bool operator!=(default_sentinel y, __iterator x);
private:
   basic_istream_view<Val, CharT, Traits>* parent_ = nullptr; // exposition-only
};
```

#### `basic_istream_view::__iterator` constructor

```cpp
explicit constexpr __iterator(istream_view<Val>& parent) noexcept;
```

6. <i>Effects</i>: Initialises `parent_` with `std::addressof(parent_)`.

#### `basic_istream_view::__iterator` next

```cpp
__iterator& operator++();
void operator++(int);
```

7. <i>Effects</i>: Equivalent to

```cpp
*parent_->stream_ >> parent_->object_;
```

#### `basic_istream_view::__iterator` value

```cpp
Val& operator*() const;
```

8. <i>Effects</i>: Equivalent to `return parent_->value_;`

#### `basic_istream_view::__iterator` comparison functions

```cpp
friend bool operator==(__iterator x, default_sentinel);
```

9. <i>Effects</i>: Equivalent to `return !*x.parent_->stream_;`.

```cpp
friend bool operator==(default_sentinel y, __iterator x);
```

10. <i>Returns</i>: `x == y`.

```cpp
friend bool operator!=(__iterator x, default_sentinel y);
```

11. <i>Returns</i>: `!(x == y)`.

```cpp
friend bool operator!=(default_sentinel y, __iterator x);
```

12. <i>Returns</i>: `!(x == y)`.

## `basic_istream_view` range adaptors

The names `view::istream`, `view::wistream`, `view::u16istream`, and `view::u32istream` denote range
adaptors. Let `E` be an expression and `T` be a type distinct from `decltype((E))`.

1. Then, the expression `istream_view<T>(E)` is expression-equivalent to:
   1. `basic_istream_view<T, char>(E)` if `decltype((E))` models `DerivedFrom<std::istream>` and `T`
      models `StreamExtractable`.
   2. Otherwise `istream_view<T>(E)` is ill-formed.
2. Then, the expression `wistream_view<T>(E)` is expression-equivalent to:
   1. `basic_istream_view<T, wchar_t>(E)` if `decltype((E))` models `DerivedFrom<std::wistream>` and
      `T` modes `StreamExtractable`.
   2. Otherwise `wistream_view<T>(E)` is ill-formed.
3. Then, the expression `u16istream_view` is expression-equivalent to:
   1. `basic_istream_view<T, char16_t>(E)` if `decltype((E))` models
      `DerivedFrom<basic_istream<char16_t>>` and `T` models `StreamExtractable`.
   2. Otherwise `u16istream_view<T>(E)` is ill-formed.
4. Then, the expression `u32istream_view` is expression-equivalent to:
   1. `basic_istream_view<T, char32_t>(E)` if `decltype((E))` models
      `DerivedFrom<basic_istream<char32_t>>` and `T` models `StreamExtractable`.
   2. Otherwise `u32istream_view<T>(E)` is ill-formed.

## `zip_view`

<b>Note: This section was formerly titled <i><code>zip_with_view</code></i> in P1035R1. Due to
complications in the design process, `zip_with_view` will not be proposed, but `zip_view` shall be.
A subsubsection below articulates how to emulate `zip_with_view` below.</b>

### Motivation

A zip, also known as a [[convolution]] operation, performs a transformation on multiple input
ranges. The typical zip operation transforms several input ranges into a single input range
containing a tuple with the <i>i</i>th element from each range, and terminates when the smallest
finite range is delimited. The following example has been adapted from [[P0836]] &sect;2.1.

<table>
  <tr><th>Current (C++17)</th><th>Proposed (C++20)</th></tr>
  <tr>
    <td>
      <xmp>
vector<float> const x = // ...
vector<float> const y = // ...
float a = // ...
// ...
auto result = vector<float>(size(x));
transform(x, y, begin(result), [a](auto const x, auto const y) {
   return a * x + y; });
      </xmp>
    </td>
    <td>
      <xmp>
vector<float> const x = // ...
vector<float> const y = // ...
float const a = // ...
// ...
auto const pair_mult = [](auto const& ax){ auto [a, x] = ax; return a * x; };
auto const pair_plus = [](auto const& axpy){ auto [ax, y] = axpy; return ax + y; };
auto ax = view::zip(view::repeat(a), x) | view::transform(pair_mult);
auto saxpy = view::zip(ax, y) | view::transform(pair_plus);
auto const result = vector(begin(saxpy), end(saxpy));
      </xmp>
    </td>
  </tr>
</table>

The benefits of this proposed approach include:

* More <i>declared</i> operations, leading to more declarative -- rather than imperative -- style
    programming.
* Eliminates state.
* `result` can be declared `const` without needing to rely on IILE. (Note the lack of IILE and the
    non-`const`ness in the former).
* Temporary storage is eliminated, which P0836 &sect;2.1 articulates as beneficial for heterogeneous
    programming.

Another motivating example for using `zip` involves replacing raw loops with algorithms and range
adaptors, but still being able to index the operation in question.

<table>
  <tr><th>Current (C++17)</th><th>Proposed (C++20)</th></tr>
  <tr>
    <td>
      <xmp>
auto v = vector(istream_iterator<int>(std::cin), istream_iterator<int>());
auto weighted_sum = 0;
for (auto i = 0; i < ranges::distance(v); ++i) {
   weighted_sum += i * v[i];
}
      </xmp>
    </td>
    <td>
      <xmp>
auto in = view::zip(view::iota(0), istream_range<int>{std::cin});
auto weighted_sum = accumulate(begin(in), end(in), [](auto const a, auto const b){
   auto const [index, in] = b;
   return a + (index * in);
});
      </xmp>
    </td>
  </tr>
</table>

#### `zip_with` in C++20

`zip_with` is a generalisation of `zip`, such that we can apply an <i>n</i>-ary function in place of
the `transform`s above. The following is an example of how `zip_with` can refine `zip` when tuples
are not necessary.

```cpp
vector<float> const x = // ...
vector<float> const y = // ...
float const a = // ...
// ...
auto ax = x | view::transform([a](auto const x) noexcept { return a * x; });
auto saxpy = view::zip_with(plus<>{}, ax, y);
auto const result = vector(begin(saxpy), end(saxpy));
```

As `zip_with_view` is no longer proposed in C++20, users wanting `zip_with` functionality will be
required to use:

<xmp>
template<class F>
constexpr auto compose_apply(F&& f) {
   return [f = std::forward<F>(f)](auto&& t) {
      return std::apply(std::forward<F>(f), std::forward<decltype(t)>(t));
   };
};

// ...
auto saxpy = zip(ax, y) | transform(compose_apply(std::plus<>{}));
</xmp>

This isn't an ideal approach, but some of the finer details of `zip_with_view` that are independent
of `zip_view` are still being worked out, and this should not preclude the usage of zipping ranges
for maximum composability.

### Example implementation

The following implementation has been taken from cmcstl2:

<xmp>
template<WeaklyIncrementable... Ts>
using __common_difference_type_t =
	meta::_t<meta::if_c<sizeof...(Ts) != 0,
		common_type<iter_difference_t<Ts>...>,
		meta::id<int>>>;

template<View... Rs>
struct __zip_view_base {
	std::tuple<iterator_t<Rs>...> current_ {};
};
template<View... Rs>
requires (ForwardRange<Rs> && ...)
struct __zip_view_base<Rs...> {};

template<View... Rs>
struct zip_view
: view_interface<zip_view<Rs...>>
, private __zip_view_base<Rs...>
{
private:
	template <bool Const, class Indices> struct __zipperator;
	template <bool Const, class Indices> struct __sentinel;
	using Indices = std::index_sequence_for<Rs...>;
	static constexpr bool all_simple = (ext::SimpleView<Rs> && ...);
	static constexpr bool all_forward = (ForwardRange<Rs> && ...);
	static constexpr bool all_forward_const = (ForwardRange<const Rs> && ...);
	static constexpr bool all_sized = (SizedRange<Rs> && ...);
	static constexpr bool all_sized_const = (SizedRange<const Rs> && ...);

	std::tuple<Rs...> ranges_ {};

	template<std::size_t... Is, class Self>
	static constexpr auto size_(std::index_sequence<Is...>, Self& self)
	{
		if constexpr (sizeof...(Rs) != 0) {
			static_assert(Same<std::index_sequence<Is...>, Indices>);
			using D = __common_difference_type_t<iterator_t<Rs>...>;
			return ranges::min({static_cast<D>(
				ranges::size(std::get<Is>(self.ranges_)))...});
		} else {
			return 0;
		}
	}
	template<std::size_t... Is>
	constexpr void begin_(std::index_sequence<Is...>)
	{ (((void)(std::get<Is>(this->current_) = ranges::begin(std::get<Is>(ranges_)))), ...); }
public:
	zip_view() = default;
	constexpr zip_view(Rs... rs)
	noexcept((std::is_nothrow_move_constructible_v<Rs> && ...))
	requires sizeof...(Rs) != 0
	: ranges_(std::move(rs)...) {}

	constexpr auto begin() {
		if constexpr (!all_forward) begin_(Indices{});
		return __zipperator<all_simple && all_forward, Indices>{*this};
	}
	constexpr auto begin() const requires all_forward_const
	{ return __zipperator<true, Indices>{*this}; }

	constexpr auto end() requires all_forward
	{
		if constexpr ((RandomAccessRange<Rs> && ...) && all_sized)
			return __zipperator<all_simple, Indices>{*this, size_(Indices{}, *this)};
		else
			return __sentinel<all_simple, Indices>{*this};
	}
	constexpr auto end() const
	{
		if constexpr ((RandomAccessRange<const Rs> && ...) && all_sized_const)
			return __zipperator<true, Indices>{*this, size_(Indices{}, *this)};
		else if constexpr (all_forward && all_forward_const)
			return __sentinel<true, Indices>{*this};
		else
			return default_sentinel{};
	}

	constexpr auto size() requires all_sized
	{ return size_(Indices{}, *this); }
	constexpr auto size() const requires all_sized_const
	{ return size_(Indices{}, *this); }
};

template <class... Rs>
zip_view(Rs&&...) -> zip_view<all_view<Rs>...>;

template<bool, View... Rs>
struct __zipperator_base {
	zip_view<Rs...>* parent_ = nullptr;
};
template<bool Const, View... Rs>
requires (ForwardRange<__maybe_const<Const, Rs>> && ...)
struct __zipperator_base<Const, Rs...> {
	std::tuple<iterator_t<__maybe_const<Const, Rs>>...> current_ {};
};

template<bool, View... Rs>
struct __zipperator_vt_base {};
template<bool Const, View... Rs>
requires (InputRange<__maybe_const<Const, Rs>> && ...)
struct __zipperator_vt_base<Const, Rs...> {
	using value_type = std::tuple<
		iter_value_t<iterator_t<__maybe_const<Const, Rs>>>...>;
};

template<View... Rs>
template<bool Const, std::size_t... Is>
struct zip_view<Rs...>::__zipperator<Const, std::index_sequence<Is...>>
: private __zipperator_base<Const, Rs...>
, __zipperator_vt_base<Const, Rs...>
{
private:
	using Parent = __maybe_const<Const, zip_view<Rs...>>;
	using Sent = typename zip_view<Rs...>::template
		__sentinel<Const, std::index_sequence<Is...>>;

	static constexpr bool all_random_access =
		(RandomAccessRange<__maybe_const<Const, Rs>> && ...);
	static constexpr bool all_bidi =
		(BidirectionalRange<__maybe_const<Const, Rs>> && ...);
	static constexpr bool all_forward =
		(ForwardRange<__maybe_const<Const, Rs>> && ...);
	static constexpr bool all_input =
		(InputRange<__maybe_const<Const, Rs>> && ...);

	static_assert(!Const || all_forward);
	static_assert(Same<std::index_sequence_for<Rs...>,
		std::index_sequence<Is...>>);

	auto& current() noexcept requires all_forward
	{ return this->current_; }
	auto& current() const noexcept {
		if constexpr (all_forward)
			return this->current_;
		else
			return this->parent_->current_;
	}

public:
	using iterator_category =
		meta::if_c<all_random_access, random_access_iterator_tag,
		meta::if_c<all_bidi, bidirectional_iterator_tag,
		meta::if_c<all_forward, forward_iterator_tag,
		meta::if_c<all_input, input_iterator_tag,
		output_iterator_tag>>>>;
	using difference_type = __common_difference_type_t<
		iterator_t<__maybe_const<Const, Rs>>...>;

	__zipperator() = default;
	explicit constexpr __zipperator(Parent& parent)
	: __zipperator_base<Const, Rs...>{detail::addressof(parent)}
	{}
	constexpr __zipperator(Parent& parent)
	requires all_forward
	: __zipperator_base<Const, Rs...>{{
		(ranges::begin(std::get<Is>(parent.ranges_)))...
	}} {}
	constexpr __zipperator(Parent& parent, [[maybe_unused]] difference_type n)
	requires all_random_access
	: __zipperator_base<Const, Rs...>{{
		(ranges::begin(std::get<Is>(parent.ranges_)) +
			static_cast<iter_difference_t<iterator_t<__maybe_const<Const, Rs>>>>(n))...
	}} {}

	constexpr auto operator*()
	{ return __tuple_hack{*std::get<Is>(current())...}; }
	constexpr auto operator*() const
	requires (detail::Dereferenceable<const iterator_t<__maybe_const<Const, Rs>>> && ...)
	{ return __tuple_hack{*std::get<Is>(current())...}; }

	constexpr __zipperator& operator++() {
		((void)++std::get<Is>(current()), ...);
		return *this;
	}
	constexpr auto operator++(int) {
		if constexpr (all_forward) {
			auto tmp = *this;
			++*this;
			return tmp;
		} else
			++*this;
	}

	constexpr __zipperator& operator--()
	requires all_bidi
	{
		((void)--std::get<Is>(current()), ...);
		return *this;
	}
	constexpr __zipperator operator--(int)
	requires all_bidi
	{
		auto tmp = *this;
		--*this;
		return tmp;
	}

	friend constexpr bool operator==(const __zipperator& x, const __zipperator& y)
	requires all_forward
	{ return x.current_ == y.current_; }
	friend constexpr bool operator!=(const __zipperator& x, const __zipperator& y)
	requires all_forward
	{ return !(x == y); }

	friend constexpr bool operator==(const __zipperator& x, default_sentinel)
	requires !all_forward
	{ return ((std::get<Is>(x.current()) == ranges::end(std::get<Is>(x.parent_->ranges_))) || ...); }
	friend constexpr bool operator==(default_sentinel y, const __zipperator& x)
	requires !all_forward
	{ return (x == y); }
	friend constexpr bool operator!=(const __zipperator& x, default_sentinel y)
	requires !all_forward
	{ return !(x == y); }
	friend constexpr bool operator!=(default_sentinel y, const __zipperator& x)
	requires !all_forward
	{ return !(y == x); }

	friend constexpr bool operator==(const __zipperator& x, const Sent& y)
	requires all_forward
	{ return ((std::get<Is>(current()) == std::get<Is>(y.last_)) || ...); }
	friend constexpr bool operator==(const Sent& y, const __zipperator& x)
	requires all_forward
	{ return (x == y); }
	friend constexpr bool operator!=(const __zipperator& x, const Sent& y)
	requires all_forward
	{ return !(x == y); }
	friend constexpr bool operator!=(const Sent& y, const __zipperator& x)
	requires all_forward
	{ return !(y == x); }

	friend constexpr bool operator<(const __zipperator& x, const __zipperator& y)
	requires all_random_access
	{ return x.current_ < y.current_; }
	friend constexpr bool operator>(const __zipperator& x, const __zipperator& y)
	requires all_random_access
	{ return y < x; }
	friend constexpr bool operator<=(const __zipperator& x, const __zipperator& y)
	requires all_random_access
	{ return !(y < x); }
	friend constexpr bool operator>=(const __zipperator& x, const __zipperator& y)
	requires all_random_access
	{ return !(x < y); }

	constexpr __zipperator& operator+=([[maybe_unused]] difference_type n)
	requires all_random_access
	{
		((void)(std::get<Is>(current()) += n), ...);
		return *this;
	}
	friend constexpr __zipperator operator+(const __zipperator& x, difference_type n)
	requires all_random_access
	{
		auto tmp = x;
		tmp += n;
		return tmp;
	}
	friend constexpr __zipperator operator+(difference_type n, const __zipperator& x)
	requires all_random_access
	{ return x + n; }

	constexpr __zipperator& operator-=([[maybe_unused]] difference_type n)
	requires all_random_access
	{
		((void)(std::get<Is>(current()) -= n), ...);
		return *this;
	}
	friend constexpr __zipperator operator-(const __zipperator& x, difference_type n)
	requires all_random_access
	{
		auto tmp = x;
		tmp -= n;
		return tmp;
	}
	friend constexpr difference_type operator-(const __zipperator& x, const __zipperator& y)
	requires (SizedSentinel<iterator_t<__maybe_const<Const, Rs>>,
		iterator_t<__maybe_const<Const, Rs>>> && ...)
	{
		if constexpr (sizeof...(Rs) != 0) {
			return ranges::max({static_cast<difference_type>(
				std::get<Is>(x.current()) - std::get<Is>(y.current()))...});
		} else {
			return 0;
		}
	}

	constexpr auto operator[](difference_type n) const
	requires all_random_access
	{ return *(*this + n); }

	friend constexpr auto iter_move(const __zipperator& x)
	noexcept(noexcept(((void)ranges::iter_move(
		std::declval<const iterator_t<__maybe_const<Const, Rs>>&>()), ...)))
	requires ((Readable<iterator_t<__maybe_const<Const, Rs>>> && ...))
	{ return __tuple_hack{ranges::iter_move(std::get<Is>(x.current()))...}; }

	friend constexpr void iter_swap(const __zipperator& x, const __zipperator& y)
	noexcept(noexcept((ranges::iter_swap(
		std::declval<const iterator_t<__maybe_const<Const, Rs>>&>(),
		std::declval<const iterator_t<__maybe_const<Const, Rs>>&>()), ...)))
	requires (IndirectlySwappable<iterator_t<__maybe_const<Const, Rs>>> && ...)
	{ (ranges::iter_swap(std::get<Is>(x.current()), std::get<Is>(y.current())), ...); }
};

template<View... Rs>
template<bool Const, std::size_t... Is>
struct zip_view<Rs...>::__sentinel<Const, std::index_sequence<Is...>> {
private:
	using Iter = typename zip_view<Rs...>::template
		__zipperator<Const, std::index_sequence<Is...>>;
	friend Iter;
	using Parent = __maybe_const<Const, zip_view<Rs...>>;
	static constexpr bool all_forward =
		(ForwardRange<__maybe_const<Const, Rs>> && ...);
	static_assert(all_forward);
	static_assert(Same<std::index_sequence_for<Rs...>,
		std::index_sequence<Is...>>);

	std::tuple<sentinel_t<__maybe_const<Const, Rs>>...> last_;

public:
	__sentinel() = default;
	explicit constexpr __sentinel(Parent& parent)
	: last_{ranges::end(std::get<Is>(parent.ranges_))...}
	{}
};
} // namespace ext

namespace view {
struct __zip_fn {
	template<class... Rs>
	requires requires(Rs&&... rs) {
		ranges::ext::zip_view{view::all(static_cast<Rs>(rs))...};
	}
	constexpr auto operator()(Rs&&... rs) const
	STL2_NOEXCEPT_RETURN(
		ranges::ext::zip_view{view::all(static_cast<Rs>(rs))...}
	)
};

inline constexpr __zip_fn zip{};
</xmp>

### Problems with `std::pair` and `std::tuple`

`zip_view` requires a value type to store the values of the iterators to the ranges that are
iterated over, and a reference type to access those values via an iterator to the range.
Additionally, the concept "`Writable` wants `const` proxy references to be assignable, so we need a
tuple-like type with `const`-qualified assignment operators"[[cmcstl2/zip_view]].

Both range-v3 and the cmcstl2 implementation above use an exposition-only type derived from
`std::tuple` (both) or `std::pair` (range-v3 only) that permits a `CommonReference` between
`tuple<Ts...>&` (an lvalue reference to the value type) and `tuple<Ts&...>` (the perceived reference
type). This is deemed to be a hack by both Eric Niebler and Casey Carter; a careful reader might
notice that the above implementation specifies this as `__tuple_hack` (which has conveniently been
left out of P1035).

Adding a third (and possibly fourth) tuple type that is exposition-only is <i>not</i> ideal: this
requires extensions to both `pair` and `tuple` so that they are compatible with `__tuple_hack` and
`__pair_hack`, specialisations for all tuple utilities will be required, and overloads to `get`,
`apply`, etc. are also necessary.

Alternatively, we can provide an implicit conversion from `tuple<Ts...>&` to `tuple<Ts&...>`, and
ensure that a `common_reference` exists (à la `basic_common_reference`), and similarly for the other
reference types.

<xmp>
template<class... Ts>
struct tuple {
	// ...

	constexpr tuple const& operator=(tuple<_Elements...> const&)
	requires (__stl2::Assignable<_Elements const&, _Elements const&> and ...);

	constexpr tuple const& operator=(tuple<_Elements...>&&)
	requires (__stl2::Assignable<_Elements const&, _Elements> and ...);

	template<class... Us>
	requires sizeof...(Ts) == sizeof...(Us) and (Assignable<Ts const&, Us const&> and ...)
	constexpr tuple const& operator=(tuple<Us...> const& other) const;

	template<class... Us>
	requires sizeof...(Ts) == sizeof...(Us) and (Assignable<Ts const&, Us const&> and ...)
	constexpr tuple const& operator=(tuple<Us...>&& other) const;

	constexpr operator tuple<remove_reference_t<_Elements>&...>() noexcept;
	constexpr operator tuple<remove_reference_t<_Elements> const&...>() const noexcept;
	constexpr operator tuple<remove_reference_t<_Elements>&&...>() noexcept;
	constexpr operator tuple<remove_reference_t<_Elements> const&&...>() const noexcept;
};

template<class... Ts>
requires (requires { typename common_type_t<Ts, Ts&>; } && ...)
struct common_type<tuple<Ts&...>, std::tuple<Ts...>> {
	using type = tuple<common_type_t<Ts&, Ts>...>;
};
template<class... Ts>
requires (requires { typename common_type_t<Ts, Ts&>; } && ...)
struct common_type<std::tuple<Ts...>, tuple<Ts&...>>	{
	using type = tuple<common_type_t<Ts&, Ts>...>;
};

template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts>, UQual<Ts&>>; } && ...)
struct basic_common_reference<tuple<Ts&...>, std::tuple<Ts...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<Ts&>, UQual<Ts>>...>;
};
template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts>, UQual<Ts&>>; } && ...)
struct basic_common_reference<std::tuple<Ts...>, tuple<Ts&...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<Ts>, UQual<Ts&>>...>;
};

// lvalue to rvalue reference
template<class... Ts>
requires (requires { typename common_type_t<Ts, Ts&&>; } && ...)
struct common_type<tuple<Ts&&...>, std::tuple<Ts...>> {
	using type = tuple<common_type_t<Ts&&, Ts>...>;
};
template<class... Ts>
requires (requires { typename common_type_t<Ts, Ts&&>; } && ...)
struct common_type<std::tuple<Ts...>, tuple<Ts&&...>>	{
	using type = tuple<common_type_t<Ts&&, Ts>...>;
};

template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts>, UQual<Ts&&>>; } && ...)
struct basic_common_reference<tuple<Ts&&...>, std::tuple<Ts...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<Ts&&>, UQual<Ts>>...>;
};
template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts>, UQual<Ts&&>>; } && ...)
struct basic_common_reference<std::tuple<Ts...>, tuple<Ts&&...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<Ts>, UQual<Ts&&>>...>;
};

// lvalue reference to rvalue reference
template<class... Ts>
requires (requires { typename common_type_t<Ts&, remove_reference_t<Ts>&&>; } && ...)
struct common_type<tuple<remove_reference_t<Ts>&&...>, std::tuple<Ts&...>> {
	using type = tuple<common_type_t<remove_reference_t<Ts>&&, Ts&>...>;
};
template<class... Ts>
requires (requires { typename common_type_t<Ts&, remove_reference_t<Ts>&&>; } && ...)
struct common_type<std::tuple<Ts&...>, tuple<remove_reference_t<Ts>&&...>>	{
	using type = tuple<common_type_t<remove_reference_t<Ts>&&, Ts&>...>;
};

template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts&>, UQual<remove_reference_t<Ts>&&>>; } && ...)
struct basic_common_reference<tuple<remove_reference_t<Ts>&&...>, std::tuple<Ts&...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<remove_reference_t<Ts>&&>, UQual<Ts&>>...>;
};
template<class... Ts,
	template <class> class TQual, template <class> class UQual>
requires (requires { typename common_reference_t<TQual<Ts&>, UQual<remove_reference_t<Ts>&&>>; } && ...)
struct basic_common_reference<std::tuple<Ts&...>, tuple<remove_reference_t<Ts>&&...>, TQual, UQual> {
	using type = tuple<common_reference_t<TQual<Ts&>, UQual<remove_reference_t<Ts>&&>>...>;
};
</xmp>

#### Pros and cons for fixing `tuple` (and possibly `pair`)

<table>
	<tr>
		<th>Pros</th>
		<th>Cons</th>
	</tr>
	<tr>
		<td>
			Exactly one `tuple` and one `pair` exist. 
		</td>
		<td>
			Consider this code:
<xmp>
constexpr std::tuple<int&, double&> bad_code(int i)
{
  auto t = std::tuple<int, double>{i, 0.0};
  return t;
}

int main()
{
	auto const t = bad_code(4); // BOOM! Undefined behaviour.
	auto const u = bad_code(6);
	auto const tu = std::get<0>(t) + std::get<0>(u);
	CHECK(tu == 10);
}
</xmp>

This program is undefined; GCC's `-Wuninitialized` flag identifies this, and when coupled with
`-Werror`, can force a build to fail (this is good if, and only if `-Werror` is enabled for this
warning). A naive programmer mightn't be aware that they're calling a conversion operator.

While this may not be motivation for LEWG to avoid making the changes to `tuple` directly, it is
certainly important to be aware of this issue.
		</td>
	</tr>
</table>

#### Pros and cons for introducing an exposition-only `__tuple_hack` (and possibly `__pair_hack`)

<table>
	<tr>
		<th>Pros</th>
		<th>Cons</th>
	</tr>
	<tr>
		<td>Dangling issue resolved (users can't directly use exposition-only types).</td>
		<td>More library maintainer maintenance.</td>
	</tr>
	<tr>
		<td></td>
		<td>More overloads for `std::get`, `tuple_cat`, etc.</td>
	</tr>
</table>

#### Ensure `tuple` and `pair` assignment operators are `constexpr`

To ensure that the `constexpr`-ness of `zip_view` is not accidentally inhibited, this paper also
requests that there be some discussion on making the assignment operators of `pair` and `tuple`
`constexpr`.

## `keys` and `values`

### Motivation

It is frequent to want to iterate over the keys or the values of an associative container. There is
currently no easy way to do that. It can be approximated using `ranges::view::transform`, given how
frequently such operation is needed we think their addition would make manipulation of associative
containers easier by more clearly expressing the intent.

These views have been part of ranges-v3 and we also have implemented them in cmcstl2. A lot of
languages and frameworks (notably JS, Python, Qt, Java, [[Boost.Range]]) offer methods to extract
the keys or values of an associative container, often through `.keys()` and `.values()` operations,
respectively.

### Implementation

Given an exposition-only tuple extractor (`__get_fn`), `keys` and `values` need only be range
adaptor objects implemented in terms of `view::transform`, rather than range adaptors.

<xmp>
namespace view {
	template<int X>
	requires (X == 0) || (X == 1)
	struct __get_fn {
		template<class P>
		requires pair-like<P>
		constexpr decltype(auto) operator()(P&& p) const
		{
			using T = decltype(std::get<X>(std::forward<P>(p)));
			return std::forward<T>(std::get<X>(std::forward<P>(p)));
		}
	};

	inline constexpr auto keys = view::transform(__get_fn<0>{});
	inline constexpr auto values = view::transform(__get_fn<1>{});
} // namespace view
</xmp>

## Introducing associated types for ranges

<b>Note: This section was formerly titled <i>Reviewing `iter_value_t`, etc., and introducing
`range_value_t`, etc.</i> in P1035R1, but the current title is more accurate.</b>

[[P1037]] introduced `iter_difference_t`, `iter_value_t`, `iter_reference_t`, and
`iter_rvalue_reference_t`, which dispatch to templates that correclty identify the associated
types for iterators (formerly known as iterator traits). The current mechanism supports iterators,
but not ranges. For example, in order to extract an range's value type, we are required to do one of
three things:

<ol>
   <li>
      Use the traditional `typename T::value_type`. As we have had template aliases since C++11,
      this has probably been abandoned in many projects (not cited).
   </li>
   <li>
      Define our own associated type à la

<xmp>
template<class T>
requires requires { typename T::value_type; }
using value_type = typename T::value_type;
</xmp>

This was apparently possible in the Ranges TS (albeit in much more detail) 
[[iter.assoc.types.value_type]], but P1037 has redefined `value_type_t` as `iter_value_t`, which
focuses on iterators, rather than anything defining `value_type` alias. We <i>could</i> do this in
C++20, but we then risk `R::value_type` being different to `R::iterator::value_type` (consider
`vector<int const>::value_type` and `vector<int const>::iterator::value_type`, which are `int const`
and `int`, respectively)[[value_type]].
   </li>

   <li>
      Use `iter_value_t<iterator_t<R>>`, which what we probably want, and is also a mouthful.
   </li>
</ol>

When discussing extending `iter_value_t` so that it can also operate on ranges, Casey Carter had
this to say:

<blockquote>
   What should `iter_value_t<T>` be when `T` is an iterator with value type `U` and a range with
   value type `V`?

   Alternately: What is `iter_value_t<array<const int>>`? `array<const int>::value_type` is
   `const int`, but `iter_value_t<iterator_t<array<const int>>` is `int`.

   Specific examples aside, early attempts to make the associated type aliases "polymorphic" kept
   running into ambiguities that we had to disambiguate or simply declare broken.

   I'd rather see `range_value_t` et al proposed.
</blockquote>

P1035 introduces shorthands for `iter_foo_t<iterator_t<R>>` as `range_foo_t<R>`, which in turn have
been taken from range-v3.

```cpp
template<Range R>
using range_difference_t = iter_difference_t<iterator_t<R>>;

template<Range R>
using range_size_t = make_unsigned_t<range_difference_t<R>>;

template<InputRange R>
using range_value_t = iter_value_t<iterator_t<R>>;

template<InputRange R>
using range_reference_t = iter_reference_t<iterator_t<R>>;

template<InputRange R>
using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<R>>;

template<Range R>
requires Same<iterator_t<R>, sentinel_t<R>>
using range_common_iterator_t = common_iterator<iterator_t<R>, sentinel_t<R>>;
```

These have an enormous amount of usage in range-v3, and will ensure consistency between generic code
that uses ranges and generic code that uses iterators (which are essential for underpinning all
range abstractions in C++).

<pre class=biblio>
{
"P0789": {
    "title": "Range Adaptors and Utilities",
    "authors": ["Eric Niebler"],
    "href": "https://wg21.link/p0789"
},
"P0836": {
    "title": "P0836 Introduce Parallelism to the Ranges TS",
    "authors": ["Gordon Brown", "Christopher Di Bella", "Michael Haidl", "Toomas Remmelg", "Ruyman Reyes", "Michel Steuwer", "Michael Wong"],
    "href": "https://wg21.link/p0836"
},
"P1037": {
    "title": "Deep Integration of the Ranges TS",
    "authors": ["Eric Niebler", "Casey Carter"],
    "href": "https://wg21.link/p1037"
},
"range-v3": {
    "title": "ranges-v3 C++ library",
    "authors": ["Eric Niebler & others"],
    "href": "https://github.com/ericniebler/range-v3"
},
"cmcstl2": {
    "title": "cmcstl2 C++ library",
    "authors": ["Casey Carter & others"],
    "href": " https://github.com/CaseyCarter/cmcstl2"
},
"convolution": {
    "title": "Convolution",
    "authors": ["Wikipedia"],
    "href": "https://en.wikipedia.org/wiki/Convolution_(computer_science)"
},
"iter.assoc.types.value_type": {
   "title": "ISO/IEC TS 21425:2017 C++ Extensions for Ranges",
   "authors": ["Eric Niebler", "Casey Carter"],
   "href": "https://timsong-cpp.github.io/cppwp/ranges-ts/iterator.assoc.types.value_type"
},
"value_type": {
    "title": "static_assert(not is_same_v<vector<int const>::value_type, vector<int const>::iterator::value_type>)",
    "href": "https://godbolt.org/z/xkcREX"
},
"Boost.Range": {
	"title": "Boost.Range",
	"href": "https://www.boost.org/doc/libs/1_68_0/libs/range/doc/html/range/reference/adaptors/reference/map_values.html#range.reference.adaptors.reference.map_values.map_values_example"
}
}
</pre>   